// Autogenerated by Thrift Compiler (0.9.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package hbase

import (
	"bytes"
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

type THBaseService interface {
	// Test for the existence of columns in the table, as specified in the TGet.
	//
	// @return true if the specified TGet matches one or more keys, false if not
	//
	// Parameters:
	//  - Table: the table to check on
	//  - Tget: the TGet to check for
	Exists(table []byte, tget *TGet) (r bool, err error)
	// Test for the existence of columns in the table, as specified by the TGets.
	//
	// This will return an array of booleans. Each value will be true if the related Get matches
	// one or more keys, false if not.
	//
	// Parameters:
	//  - Table: the table to check on
	//  - Tgets: a list of TGets to check for
	ExistsAll(table []byte, tgets []*TGet) (r []bool, err error)
	// Method for getting data from a row.
	//
	// If the row cannot be found an empty Result is returned.
	// This can be checked by the empty field of the TResult
	//
	// @return the result
	//
	// Parameters:
	//  - Table: the table to get from
	//  - Tget: the TGet to fetch
	Get(table []byte, tget *TGet) (r *TResult_, err error)
	// Method for getting multiple rows.
	//
	// If a row cannot be found there will be a null
	// value in the result list for that TGet at the
	// same position.
	//
	// So the Results are in the same order as the TGets.
	//
	// Parameters:
	//  - Table: the table to get from
	//  - Tgets: a list of TGets to fetch, the Result list
	// will have the Results at corresponding positions
	// or null if there was an error
	GetMultiple(table []byte, tgets []*TGet) (r []*TResult_, err error)
	// Commit a TPut to a table.
	//
	// Parameters:
	//  - Table: the table to put data in
	//  - Tput: the TPut to put
	Put(table []byte, tput *TPut) (err error)
	// Atomically checks if a row/family/qualifier value matches the expected
	// value. If it does, it adds the TPut.
	//
	// @return true if the new put was executed, false otherwise
	//
	// Parameters:
	//  - Table: to check in and put to
	//  - Row: row to check
	//  - Family: column family to check
	//  - Qualifier: column qualifier to check
	//  - Value: the expected value, if not provided the
	// check is for the non-existence of the
	// column in question
	//  - Tput: the TPut to put if the check succeeds
	CheckAndPut(table []byte, row []byte, family []byte, qualifier []byte, value []byte, tput *TPut) (r bool, err error)
	// Commit a List of Puts to the table.
	//
	// Parameters:
	//  - Table: the table to put data in
	//  - Tputs: a list of TPuts to commit
	PutMultiple(table []byte, tputs []*TPut) (err error)
	// Deletes as specified by the TDelete.
	//
	// Note: "delete" is a reserved keyword and cannot be used in Thrift
	// thus the inconsistent naming scheme from the other functions.
	//
	// Parameters:
	//  - Table: the table to delete from
	//  - Tdelete: the TDelete to delete
	DeleteSingle(table []byte, tdelete *TDelete) (err error)
	// Bulk commit a List of TDeletes to the table.
	//
	// Throws a TIOError if any of the deletes fail.
	//
	// Always returns an empty list for backwards compatibility.
	//
	// Parameters:
	//  - Table: the table to delete from
	//  - Tdeletes: list of TDeletes to delete
	DeleteMultiple(table []byte, tdeletes []*TDelete) (r []*TDelete, err error)
	// Atomically checks if a row/family/qualifier value matches the expected
	// value. If it does, it adds the delete.
	//
	// @return true if the new delete was executed, false otherwise
	//
	// Parameters:
	//  - Table: to check in and delete from
	//  - Row: row to check
	//  - Family: column family to check
	//  - Qualifier: column qualifier to check
	//  - Value: the expected value, if not provided the
	// check is for the non-existence of the
	// column in question
	//  - Tdelete: the TDelete to execute if the check succeeds
	CheckAndDelete(table []byte, row []byte, family []byte, qualifier []byte, value []byte, tdelete *TDelete) (r bool, err error)
	// Parameters:
	//  - Table: the table to increment the value on
	//  - Tincrement: the TIncrement to increment
	Increment(table []byte, tincrement *TIncrement) (r *TResult_, err error)
	// Parameters:
	//  - Table: the table to append the value on
	//  - Tappend: the TAppend to append
	Append(table []byte, tappend *TAppend) (r *TResult_, err error)
	// Get a Scanner for the provided TScan object.
	//
	// @return Scanner Id to be used with other scanner procedures
	//
	// Parameters:
	//  - Table: the table to get the Scanner for
	//  - Tscan: the scan object to get a Scanner for
	OpenScanner(table []byte, tscan *TScan) (r int32, err error)
	// Grabs multiple rows from a Scanner.
	//
	// @return Between zero and numRows TResults
	//
	// Parameters:
	//  - ScannerId: the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
	//  - NumRows: number of rows to return
	GetScannerRows(scannerId int32, numRows int32) (r []*TResult_, err error)
	// Closes the scanner. Should be called to free server side resources timely.
	// Typically close once the scanner is not needed anymore, i.e. after looping
	// over it to get all the required rows.
	//
	// Parameters:
	//  - ScannerId: the Id of the Scanner to close *
	CloseScanner(scannerId int32) (err error)
	// mutateRow performs multiple mutations atomically on a single row.
	//
	// Parameters:
	//  - Table: table to apply the mutations
	//  - TrowMutations: mutations to apply
	MutateRow(table []byte, trowMutations *TRowMutations) (err error)
	// Get results for the provided TScan object.
	// This helper function opens a scanner, get the results and close the scanner.
	//
	// @return between zero and numRows TResults
	//
	// Parameters:
	//  - Table: the table to get the Scanner for
	//  - Tscan: the scan object to get a Scanner for
	//  - NumRows: number of rows to return
	GetScannerResults(table []byte, tscan *TScan, numRows int32) (r []*TResult_, err error)
	// Given a table and a row get the location of the region that
	// would contain the given row key.
	//
	// reload = true means the cache will be cleared and the location
	// will be fetched from meta.
	//
	// Parameters:
	//  - Table
	//  - Row
	//  - Reload
	GetRegionLocation(table []byte, row []byte, reload bool) (r *THRegionLocation, err error)
	// Get all of the region locations for a given table.
	//
	//
	// Parameters:
	//  - Table
	GetAllRegionLocations(table []byte) (r []*THRegionLocation, err error)
	// Atomically checks if a row/family/qualifier value matches the expected
	// value. If it does, it mutates the row.
	//
	// @return true if the row was mutated, false otherwise
	//
	// Parameters:
	//  - Table: to check in and delete from
	//  - Row: row to check
	//  - Family: column family to check
	//  - Qualifier: column qualifier to check
	//  - CompareOp: comparison to make on the value
	//  - Value: the expected value to be compared against, if not provided the
	// check is for the non-existence of the column in question
	//  - RowMutations: row mutations to execute if the value matches
	CheckAndMutate(table []byte, row []byte, family []byte, qualifier []byte, compareOp TCompareOp, value []byte, rowMutations *TRowMutations) (r bool, err error)
	// Get a table descriptor.
	// @return the TableDescriptor of the giving tablename
	//
	//
	// Parameters:
	//  - Table: the tablename of the table to get tableDescriptor
	GetTableDescriptor(table *TTableName) (r *TTableDescriptor, err error)
	// Get table descriptors of tables.
	// @return the TableDescriptor of the giving tablename
	//
	//
	// Parameters:
	//  - Tables: the tablename list of the tables to get tableDescriptor
	GetTableDescriptors(tables []*TTableName) (r []*TTableDescriptor, err error)
	//
	// @return true if table exists already, false if not
	//
	//
	// Parameters:
	//  - TableName: the tablename of the tables to check
	TableExists(tableName *TTableName) (r bool, err error)
	// Get table descriptors of tables that match the given pattern
	// @return the tableDescriptors of the matching table
	//
	//
	// Parameters:
	//  - Regex: The regular expression to match against
	//  - IncludeSysTables: set to false if match only against userspace tables
	GetTableDescriptorsByPattern(regex string, includeSysTables bool) (r []*TTableDescriptor, err error)
	// Get table descriptors of tables in the given namespace
	// @return the tableDescriptors in the namespce
	//
	//
	// Parameters:
	//  - Name: The namesapce's name
	GetTableDescriptorsByNamespace(name string) (r []*TTableDescriptor, err error)
	// Get table names of tables that match the given pattern
	// @return the table names of the matching table
	//
	//
	// Parameters:
	//  - Regex: The regular expression to match against
	//  - IncludeSysTables: set to false if match only against userspace tables
	GetTableNamesByPattern(regex string, includeSysTables bool) (r []*TTableName, err error)
	// Get table names of tables in the given namespace
	// @return the table names of the matching table
	//
	//
	// Parameters:
	//  - Name: The namesapce's name
	GetTableNamesByNamespace(name string) (r []*TTableName, err error)
	// Creates a new table with an initial set of empty regions defined by the specified split keys.
	// The total number of regions created will be the number of split keys plus one. Synchronous
	// operation.
	//
	//
	// Parameters:
	//  - Desc: table descriptor for table
	//  - SplitKeys: rray of split keys for the initial regions of the table
	CreateTable(desc *TTableDescriptor, splitKeys [][]byte) (err error)
	// Deletes a table. Synchronous operation.
	//
	//
	// Parameters:
	//  - TableName: the tablename to delete
	DeleteTable(tableName *TTableName) (err error)
	// Truncate a table. Synchronous operation.
	//
	//
	// Parameters:
	//  - TableName: the tablename to truncate
	//  - PreserveSplits: whether to  preserve previous splits
	TruncateTable(tableName *TTableName, preserveSplits bool) (err error)
	// Enalbe a table
	//
	//
	// Parameters:
	//  - TableName: the tablename to enable
	EnableTable(tableName *TTableName) (err error)
	// Disable a table
	//
	//
	// Parameters:
	//  - TableName: the tablename to disable
	DisableTable(tableName *TTableName) (err error)
	//
	// @return true if table is enabled, false if not
	//
	//
	// Parameters:
	//  - TableName: the tablename to check
	IsTableEnabled(tableName *TTableName) (r bool, err error)
	//
	// @return true if table is disabled, false if not
	//
	//
	// Parameters:
	//  - TableName: the tablename to check
	IsTableDisabled(tableName *TTableName) (r bool, err error)
	//
	// @return true if table is available, false if not
	//
	//
	// Parameters:
	//  - TableName: the tablename to check
	IsTableAvailable(tableName *TTableName) (r bool, err error)
	//  * Use this api to check if the table has been created with the specified number of splitkeys
	//  * which was used while creating the given table. Note : If this api is used after a table's
	//  * region gets splitted, the api may return false.
	//  *
	//  * @return true if table is available, false if not
	//  *
	//  * @deprecated Since 2.2.0. Because the same method in Table interface has been deprecated
	//  * since 2.0.0, we will remove it in 3.0.0 release.
	//  * Use {@link #isTableAvailable(TTableName tableName)} instead
	// *
	//
	// Parameters:
	//  - TableName: the tablename to check
	//  - SplitKeys: keys to check if the table has been created with all split keys
	IsTableAvailableWithSplit(tableName *TTableName, splitKeys [][]byte) (r bool, err error)
	// Add a column family to an existing table. Synchronous operation.
	//
	//
	// Parameters:
	//  - TableName: the tablename to add column family to
	//  - Column: column family descriptor of column family to be added
	AddColumnFamily(tableName *TTableName, column *TColumnFamilyDescriptor) (err error)
	// Delete a column family from a table. Synchronous operation.
	//
	//
	// Parameters:
	//  - TableName: the tablename to delete column family from
	//  - Column: name of column family to be deleted
	DeleteColumnFamily(tableName *TTableName, column []byte) (err error)
	// Modify an existing column family on a table. Synchronous operation.
	//
	//
	// Parameters:
	//  - TableName: the tablename to modify column family
	//  - Column: column family descriptor of column family to be modified
	ModifyColumnFamily(tableName *TTableName, column *TColumnFamilyDescriptor) (err error)
	// Modify an existing table
	//
	//
	// Parameters:
	//  - Desc: the descriptor of the table to modify
	ModifyTable(desc *TTableDescriptor) (err error)
	// Create a new namespace. Blocks until namespace has been successfully created or an exception is
	// thrown
	//
	//
	// Parameters:
	//  - NamespaceDesc: descriptor which describes the new namespace
	CreateNamespace(namespaceDesc *TNamespaceDescriptor) (err error)
	// Modify an existing namespace.  Blocks until namespace has been successfully modified or an
	// exception is thrown
	//
	//
	// Parameters:
	//  - NamespaceDesc: descriptor which describes the new namespace
	ModifyNamespace(namespaceDesc *TNamespaceDescriptor) (err error)
	// Delete an existing namespace. Only empty namespaces (no tables) can be removed.
	// Blocks until namespace has been successfully deleted or an
	// exception is thrown.
	//
	//
	// Parameters:
	//  - Name: namespace name
	DeleteNamespace(name string) (err error)
	// Get a namespace descriptor by name.
	// @retrun the descriptor
	//
	//
	// Parameters:
	//  - Name: name of namespace descriptor
	GetNamespaceDescriptor(name string) (r *TNamespaceDescriptor, err error)
	// @return all namespaces
	//
	ListNamespaceDescriptors() (r []*TNamespaceDescriptor, err error)
	// @return all namespace names
	//
	ListNamespaces() (r []string, err error)
	// Get the type of this thrift server.
	//
	// @return the type of this thrift server
	GetThriftServerType() (r TThriftServerType, err error)
	// Retrieves online slow RPC logs from the provided list of
	// RegionServers
	//
	// @return online slowlog response list
	// @throws TIOError if a remote or network exception occurs
	//
	// Parameters:
	//  - ServerNames: @param serverNames Server names to get slowlog responses from
	//  - LogQueryFilter: @param logQueryFilter filter to be used if provided
	GetSlowLogResponses(serverNames map[*TServerName]bool, logQueryFilter *TLogQueryFilter) (r []*TOnlineLogRecord, err error)
	// Clears online slow/large RPC logs from the provided list of
	// RegionServers
	//
	// @return List of booleans representing if online slowlog response buffer is cleaned
	//   from each RegionServer
	// @throws TIOError if a remote or network exception occurs
	//
	// Parameters:
	//  - ServerNames: @param serverNames Set of Server names to clean slowlog responses from
	ClearSlowLogResponses(serverNames map[*TServerName]bool) (r []bool, err error)
}

type THBaseServiceClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewTHBaseServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *THBaseServiceClient {
	return &THBaseServiceClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewTHBaseServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *THBaseServiceClient {
	return &THBaseServiceClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Test for the existence of columns in the table, as specified in the TGet.
//
// @return true if the specified TGet matches one or more keys, false if not
//
// Parameters:
//  - Table: the table to check on
//  - Tget: the TGet to check for
func (client *THBaseServiceClient) Exists(table []byte, tget *TGet) (r bool, err error) {
	if err = client.sendExists(table, tget); err != nil {
		return
	}
	return client.recvExists()
}

func (client *THBaseServiceClient) sendExists(table []byte, tget *TGet) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("exists", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := ExistsArgs{
		Table: table,
		Tget:  tget,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvExists() (value bool, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error32 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error33 error
		error33, err = error32.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error33
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "exists failed: out of sequence response")
		return
	}
	result := ExistsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Test for the existence of columns in the table, as specified by the TGets.
//
// This will return an array of booleans. Each value will be true if the related Get matches
// one or more keys, false if not.
//
// Parameters:
//  - Table: the table to check on
//  - Tgets: a list of TGets to check for
func (client *THBaseServiceClient) ExistsAll(table []byte, tgets []*TGet) (r []bool, err error) {
	if err = client.sendExistsAll(table, tgets); err != nil {
		return
	}
	return client.recvExistsAll()
}

func (client *THBaseServiceClient) sendExistsAll(table []byte, tgets []*TGet) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("existsAll", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := ExistsAllArgs{
		Table: table,
		Tgets: tgets,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvExistsAll() (value []bool, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error34 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error35 error
		error35, err = error34.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error35
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "existsAll failed: out of sequence response")
		return
	}
	result := ExistsAllResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Method for getting data from a row.
//
// If the row cannot be found an empty Result is returned.
// This can be checked by the empty field of the TResult
//
// @return the result
//
// Parameters:
//  - Table: the table to get from
//  - Tget: the TGet to fetch
func (client *THBaseServiceClient) Get(table []byte, tget *TGet) (r *TResult_, err error) {
	if err = client.sendGet(table, tget); err != nil {
		return
	}
	return client.recvGet()
}

func (client *THBaseServiceClient) sendGet(table []byte, tget *TGet) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("get", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := GetArgs{
		Table: table,
		Tget:  tget,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvGet() (value *TResult_, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error36 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error37 error
		error37, err = error36.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error37
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get failed: out of sequence response")
		return
	}
	result := GetResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Method for getting multiple rows.
//
// If a row cannot be found there will be a null
// value in the result list for that TGet at the
// same position.
//
// So the Results are in the same order as the TGets.
//
// Parameters:
//  - Table: the table to get from
//  - Tgets: a list of TGets to fetch, the Result list
// will have the Results at corresponding positions
// or null if there was an error
func (client *THBaseServiceClient) GetMultiple(table []byte, tgets []*TGet) (r []*TResult_, err error) {
	if err = client.sendGetMultiple(table, tgets); err != nil {
		return
	}
	return client.recvGetMultiple()
}

func (client *THBaseServiceClient) sendGetMultiple(table []byte, tgets []*TGet) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("getMultiple", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := GetMultipleArgs{
		Table: table,
		Tgets: tgets,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvGetMultiple() (value []*TResult_, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error38 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error39 error
		error39, err = error38.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error39
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getMultiple failed: out of sequence response")
		return
	}
	result := GetMultipleResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Commit a TPut to a table.
//
// Parameters:
//  - Table: the table to put data in
//  - Tput: the TPut to put
func (client *THBaseServiceClient) Put(table []byte, tput *TPut) (err error) {
	if err = client.sendPut(table, tput); err != nil {
		return
	}
	return client.recvPut()
}

func (client *THBaseServiceClient) sendPut(table []byte, tput *TPut) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("put", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := PutArgs{
		Table: table,
		Tput:  tput,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvPut() (err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error40 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error41 error
		error41, err = error40.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error41
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "put failed: out of sequence response")
		return
	}
	result := PutResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Atomically checks if a row/family/qualifier value matches the expected
// value. If it does, it adds the TPut.
//
// @return true if the new put was executed, false otherwise
//
// Parameters:
//  - Table: to check in and put to
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - Value: the expected value, if not provided the
// check is for the non-existence of the
// column in question
//  - Tput: the TPut to put if the check succeeds
func (client *THBaseServiceClient) CheckAndPut(table []byte, row []byte, family []byte, qualifier []byte, value []byte, tput *TPut) (r bool, err error) {
	if err = client.sendCheckAndPut(table, row, family, qualifier, value, tput); err != nil {
		return
	}
	return client.recvCheckAndPut()
}

func (client *THBaseServiceClient) sendCheckAndPut(table []byte, row []byte, family []byte, qualifier []byte, value []byte, tput *TPut) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("checkAndPut", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := CheckAndPutArgs{
		Table:     table,
		Row:       row,
		Family:    family,
		Qualifier: qualifier,
		Value:     value,
		Tput:      tput,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvCheckAndPut() (value bool, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error42 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error43 error
		error43, err = error42.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error43
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "checkAndPut failed: out of sequence response")
		return
	}
	result := CheckAndPutResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Commit a List of Puts to the table.
//
// Parameters:
//  - Table: the table to put data in
//  - Tputs: a list of TPuts to commit
func (client *THBaseServiceClient) PutMultiple(table []byte, tputs []*TPut) (err error) {
	if err = client.sendPutMultiple(table, tputs); err != nil {
		return
	}
	return client.recvPutMultiple()
}

func (client *THBaseServiceClient) sendPutMultiple(table []byte, tputs []*TPut) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("putMultiple", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := PutMultipleArgs{
		Table: table,
		Tputs: tputs,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvPutMultiple() (err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error44 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error45 error
		error45, err = error44.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error45
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "putMultiple failed: out of sequence response")
		return
	}
	result := PutMultipleResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Deletes as specified by the TDelete.
//
// Note: "delete" is a reserved keyword and cannot be used in Thrift
// thus the inconsistent naming scheme from the other functions.
//
// Parameters:
//  - Table: the table to delete from
//  - Tdelete: the TDelete to delete
func (client *THBaseServiceClient) DeleteSingle(table []byte, tdelete *TDelete) (err error) {
	if err = client.sendDeleteSingle(table, tdelete); err != nil {
		return
	}
	return client.recvDeleteSingle()
}

func (client *THBaseServiceClient) sendDeleteSingle(table []byte, tdelete *TDelete) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("deleteSingle", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := DeleteSingleArgs{
		Table:   table,
		Tdelete: tdelete,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvDeleteSingle() (err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error46 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error47 error
		error47, err = error46.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error47
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteSingle failed: out of sequence response")
		return
	}
	result := DeleteSingleResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Bulk commit a List of TDeletes to the table.
//
// Throws a TIOError if any of the deletes fail.
//
// Always returns an empty list for backwards compatibility.
//
// Parameters:
//  - Table: the table to delete from
//  - Tdeletes: list of TDeletes to delete
func (client *THBaseServiceClient) DeleteMultiple(table []byte, tdeletes []*TDelete) (r []*TDelete, err error) {
	if err = client.sendDeleteMultiple(table, tdeletes); err != nil {
		return
	}
	return client.recvDeleteMultiple()
}

func (client *THBaseServiceClient) sendDeleteMultiple(table []byte, tdeletes []*TDelete) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("deleteMultiple", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := DeleteMultipleArgs{
		Table:    table,
		Tdeletes: tdeletes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvDeleteMultiple() (value []*TDelete, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error48 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error49 error
		error49, err = error48.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error49
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteMultiple failed: out of sequence response")
		return
	}
	result := DeleteMultipleResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Atomically checks if a row/family/qualifier value matches the expected
// value. If it does, it adds the delete.
//
// @return true if the new delete was executed, false otherwise
//
// Parameters:
//  - Table: to check in and delete from
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - Value: the expected value, if not provided the
// check is for the non-existence of the
// column in question
//  - Tdelete: the TDelete to execute if the check succeeds
func (client *THBaseServiceClient) CheckAndDelete(table []byte, row []byte, family []byte, qualifier []byte, value []byte, tdelete *TDelete) (r bool, err error) {
	if err = client.sendCheckAndDelete(table, row, family, qualifier, value, tdelete); err != nil {
		return
	}
	return client.recvCheckAndDelete()
}

func (client *THBaseServiceClient) sendCheckAndDelete(table []byte, row []byte, family []byte, qualifier []byte, value []byte, tdelete *TDelete) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("checkAndDelete", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := CheckAndDeleteArgs{
		Table:     table,
		Row:       row,
		Family:    family,
		Qualifier: qualifier,
		Value:     value,
		Tdelete:   tdelete,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvCheckAndDelete() (value bool, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error50 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error51 error
		error51, err = error50.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error51
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "checkAndDelete failed: out of sequence response")
		return
	}
	result := CheckAndDeleteResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Table: the table to increment the value on
//  - Tincrement: the TIncrement to increment
func (client *THBaseServiceClient) Increment(table []byte, tincrement *TIncrement) (r *TResult_, err error) {
	if err = client.sendIncrement(table, tincrement); err != nil {
		return
	}
	return client.recvIncrement()
}

func (client *THBaseServiceClient) sendIncrement(table []byte, tincrement *TIncrement) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("increment", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := IncrementArgs{
		Table:      table,
		Tincrement: tincrement,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvIncrement() (value *TResult_, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error52 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error53 error
		error53, err = error52.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error53
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "increment failed: out of sequence response")
		return
	}
	result := IncrementResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Table: the table to append the value on
//  - Tappend: the TAppend to append
func (client *THBaseServiceClient) Append(table []byte, tappend *TAppend) (r *TResult_, err error) {
	if err = client.sendAppend(table, tappend); err != nil {
		return
	}
	return client.recvAppend()
}

func (client *THBaseServiceClient) sendAppend(table []byte, tappend *TAppend) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("append", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := AppendArgs{
		Table:   table,
		Tappend: tappend,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvAppend() (value *TResult_, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error54 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error55 error
		error55, err = error54.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error55
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "append failed: out of sequence response")
		return
	}
	result := AppendResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get a Scanner for the provided TScan object.
//
// @return Scanner Id to be used with other scanner procedures
//
// Parameters:
//  - Table: the table to get the Scanner for
//  - Tscan: the scan object to get a Scanner for
func (client *THBaseServiceClient) OpenScanner(table []byte, tscan *TScan) (r int32, err error) {
	if err = client.sendOpenScanner(table, tscan); err != nil {
		return
	}
	return client.recvOpenScanner()
}

func (client *THBaseServiceClient) sendOpenScanner(table []byte, tscan *TScan) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("openScanner", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := OpenScannerArgs{
		Table: table,
		Tscan: tscan,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvOpenScanner() (value int32, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error56 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error57 error
		error57, err = error56.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error57
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "openScanner failed: out of sequence response")
		return
	}
	result := OpenScannerResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Grabs multiple rows from a Scanner.
//
// @return Between zero and numRows TResults
//
// Parameters:
//  - ScannerId: the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
//  - NumRows: number of rows to return
func (client *THBaseServiceClient) GetScannerRows(scannerId int32, numRows int32) (r []*TResult_, err error) {
	if err = client.sendGetScannerRows(scannerId, numRows); err != nil {
		return
	}
	return client.recvGetScannerRows()
}

func (client *THBaseServiceClient) sendGetScannerRows(scannerId int32, numRows int32) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("getScannerRows", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := GetScannerRowsArgs{
		ScannerId: scannerId,
		NumRows:   numRows,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvGetScannerRows() (value []*TResult_, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error58 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error59 error
		error59, err = error58.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error59
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getScannerRows failed: out of sequence response")
		return
	}
	result := GetScannerRowsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	} else if result.Ia != nil {
		err = result.Ia
		return
	}
	value = result.GetSuccess()
	return
}

// Closes the scanner. Should be called to free server side resources timely.
// Typically close once the scanner is not needed anymore, i.e. after looping
// over it to get all the required rows.
//
// Parameters:
//  - ScannerId: the Id of the Scanner to close *
func (client *THBaseServiceClient) CloseScanner(scannerId int32) (err error) {
	if err = client.sendCloseScanner(scannerId); err != nil {
		return
	}
	return client.recvCloseScanner()
}

func (client *THBaseServiceClient) sendCloseScanner(scannerId int32) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("closeScanner", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := CloseScannerArgs{
		ScannerId: scannerId,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvCloseScanner() (err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error60 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error61 error
		error61, err = error60.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error61
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "closeScanner failed: out of sequence response")
		return
	}
	result := CloseScannerResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	} else if result.Ia != nil {
		err = result.Ia
		return
	}
	return
}

// mutateRow performs multiple mutations atomically on a single row.
//
// Parameters:
//  - Table: table to apply the mutations
//  - TrowMutations: mutations to apply
func (client *THBaseServiceClient) MutateRow(table []byte, trowMutations *TRowMutations) (err error) {
	if err = client.sendMutateRow(table, trowMutations); err != nil {
		return
	}
	return client.recvMutateRow()
}

func (client *THBaseServiceClient) sendMutateRow(table []byte, trowMutations *TRowMutations) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("mutateRow", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := MutateRowArgs{
		Table:         table,
		TrowMutations: trowMutations,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvMutateRow() (err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error62 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error63 error
		error63, err = error62.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error63
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "mutateRow failed: out of sequence response")
		return
	}
	result := MutateRowResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Get results for the provided TScan object.
// This helper function opens a scanner, get the results and close the scanner.
//
// @return between zero and numRows TResults
//
// Parameters:
//  - Table: the table to get the Scanner for
//  - Tscan: the scan object to get a Scanner for
//  - NumRows: number of rows to return
func (client *THBaseServiceClient) GetScannerResults(table []byte, tscan *TScan, numRows int32) (r []*TResult_, err error) {
	if err = client.sendGetScannerResults(table, tscan, numRows); err != nil {
		return
	}
	return client.recvGetScannerResults()
}

func (client *THBaseServiceClient) sendGetScannerResults(table []byte, tscan *TScan, numRows int32) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("getScannerResults", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := GetScannerResultsArgs{
		Table:   table,
		Tscan:   tscan,
		NumRows: numRows,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvGetScannerResults() (value []*TResult_, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error64 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error65 error
		error65, err = error64.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error65
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getScannerResults failed: out of sequence response")
		return
	}
	result := GetScannerResultsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Given a table and a row get the location of the region that
// would contain the given row key.
//
// reload = true means the cache will be cleared and the location
// will be fetched from meta.
//
// Parameters:
//  - Table
//  - Row
//  - Reload
func (client *THBaseServiceClient) GetRegionLocation(table []byte, row []byte, reload bool) (r *THRegionLocation, err error) {
	if err = client.sendGetRegionLocation(table, row, reload); err != nil {
		return
	}
	return client.recvGetRegionLocation()
}

func (client *THBaseServiceClient) sendGetRegionLocation(table []byte, row []byte, reload bool) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("getRegionLocation", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := GetRegionLocationArgs{
		Table:  table,
		Row:    row,
		Reload: reload,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvGetRegionLocation() (value *THRegionLocation, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error66 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error67 error
		error67, err = error66.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error67
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRegionLocation failed: out of sequence response")
		return
	}
	result := GetRegionLocationResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get all of the region locations for a given table.
//
//
// Parameters:
//  - Table
func (client *THBaseServiceClient) GetAllRegionLocations(table []byte) (r []*THRegionLocation, err error) {
	if err = client.sendGetAllRegionLocations(table); err != nil {
		return
	}
	return client.recvGetAllRegionLocations()
}

func (client *THBaseServiceClient) sendGetAllRegionLocations(table []byte) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("getAllRegionLocations", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := GetAllRegionLocationsArgs{
		Table: table,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvGetAllRegionLocations() (value []*THRegionLocation, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error68 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error69 error
		error69, err = error68.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error69
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getAllRegionLocations failed: out of sequence response")
		return
	}
	result := GetAllRegionLocationsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Atomically checks if a row/family/qualifier value matches the expected
// value. If it does, it mutates the row.
//
// @return true if the row was mutated, false otherwise
//
// Parameters:
//  - Table: to check in and delete from
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - CompareOp: comparison to make on the value
//  - Value: the expected value to be compared against, if not provided the
// check is for the non-existence of the column in question
//  - RowMutations: row mutations to execute if the value matches
func (client *THBaseServiceClient) CheckAndMutate(table []byte, row []byte, family []byte, qualifier []byte, compareOp TCompareOp, value []byte, rowMutations *TRowMutations) (r bool, err error) {
	if err = client.sendCheckAndMutate(table, row, family, qualifier, compareOp, value, rowMutations); err != nil {
		return
	}
	return client.recvCheckAndMutate()
}

func (client *THBaseServiceClient) sendCheckAndMutate(table []byte, row []byte, family []byte, qualifier []byte, compareOp TCompareOp, value []byte, rowMutations *TRowMutations) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("checkAndMutate", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := CheckAndMutateArgs{
		Table:        table,
		Row:          row,
		Family:       family,
		Qualifier:    qualifier,
		CompareOp:    compareOp,
		Value:        value,
		RowMutations: rowMutations,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvCheckAndMutate() (value bool, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error70 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error71 error
		error71, err = error70.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error71
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "checkAndMutate failed: out of sequence response")
		return
	}
	result := CheckAndMutateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get a table descriptor.
// @return the TableDescriptor of the giving tablename
//
//
// Parameters:
//  - Table: the tablename of the table to get tableDescriptor
func (client *THBaseServiceClient) GetTableDescriptor(table *TTableName) (r *TTableDescriptor, err error) {
	if err = client.sendGetTableDescriptor(table); err != nil {
		return
	}
	return client.recvGetTableDescriptor()
}

func (client *THBaseServiceClient) sendGetTableDescriptor(table *TTableName) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("getTableDescriptor", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := GetTableDescriptorArgs{
		Table: table,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvGetTableDescriptor() (value *TTableDescriptor, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error72 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error73 error
		error73, err = error72.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error73
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTableDescriptor failed: out of sequence response")
		return
	}
	result := GetTableDescriptorResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get table descriptors of tables.
// @return the TableDescriptor of the giving tablename
//
//
// Parameters:
//  - Tables: the tablename list of the tables to get tableDescriptor
func (client *THBaseServiceClient) GetTableDescriptors(tables []*TTableName) (r []*TTableDescriptor, err error) {
	if err = client.sendGetTableDescriptors(tables); err != nil {
		return
	}
	return client.recvGetTableDescriptors()
}

func (client *THBaseServiceClient) sendGetTableDescriptors(tables []*TTableName) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("getTableDescriptors", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := GetTableDescriptorsArgs{
		Tables: tables,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvGetTableDescriptors() (value []*TTableDescriptor, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error74 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error75 error
		error75, err = error74.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error75
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTableDescriptors failed: out of sequence response")
		return
	}
	result := GetTableDescriptorsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

//
// @return true if table exists already, false if not
//
//
// Parameters:
//  - TableName: the tablename of the tables to check
func (client *THBaseServiceClient) TableExists(tableName *TTableName) (r bool, err error) {
	if err = client.sendTableExists(tableName); err != nil {
		return
	}
	return client.recvTableExists()
}

func (client *THBaseServiceClient) sendTableExists(tableName *TTableName) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("tableExists", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := TableExistsArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvTableExists() (value bool, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error76 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error77 error
		error77, err = error76.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error77
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "tableExists failed: out of sequence response")
		return
	}
	result := TableExistsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get table descriptors of tables that match the given pattern
// @return the tableDescriptors of the matching table
//
//
// Parameters:
//  - Regex: The regular expression to match against
//  - IncludeSysTables: set to false if match only against userspace tables
func (client *THBaseServiceClient) GetTableDescriptorsByPattern(regex string, includeSysTables bool) (r []*TTableDescriptor, err error) {
	if err = client.sendGetTableDescriptorsByPattern(regex, includeSysTables); err != nil {
		return
	}
	return client.recvGetTableDescriptorsByPattern()
}

func (client *THBaseServiceClient) sendGetTableDescriptorsByPattern(regex string, includeSysTables bool) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("getTableDescriptorsByPattern", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := GetTableDescriptorsByPatternArgs{
		Regex:            regex,
		IncludeSysTables: includeSysTables,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvGetTableDescriptorsByPattern() (value []*TTableDescriptor, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error78 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error79 error
		error79, err = error78.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error79
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTableDescriptorsByPattern failed: out of sequence response")
		return
	}
	result := GetTableDescriptorsByPatternResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get table descriptors of tables in the given namespace
// @return the tableDescriptors in the namespce
//
//
// Parameters:
//  - Name: The namesapce's name
func (client *THBaseServiceClient) GetTableDescriptorsByNamespace(name string) (r []*TTableDescriptor, err error) {
	if err = client.sendGetTableDescriptorsByNamespace(name); err != nil {
		return
	}
	return client.recvGetTableDescriptorsByNamespace()
}

func (client *THBaseServiceClient) sendGetTableDescriptorsByNamespace(name string) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("getTableDescriptorsByNamespace", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := GetTableDescriptorsByNamespaceArgs{
		Name: name,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvGetTableDescriptorsByNamespace() (value []*TTableDescriptor, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error80 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error81 error
		error81, err = error80.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error81
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTableDescriptorsByNamespace failed: out of sequence response")
		return
	}
	result := GetTableDescriptorsByNamespaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get table names of tables that match the given pattern
// @return the table names of the matching table
//
//
// Parameters:
//  - Regex: The regular expression to match against
//  - IncludeSysTables: set to false if match only against userspace tables
func (client *THBaseServiceClient) GetTableNamesByPattern(regex string, includeSysTables bool) (r []*TTableName, err error) {
	if err = client.sendGetTableNamesByPattern(regex, includeSysTables); err != nil {
		return
	}
	return client.recvGetTableNamesByPattern()
}

func (client *THBaseServiceClient) sendGetTableNamesByPattern(regex string, includeSysTables bool) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("getTableNamesByPattern", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := GetTableNamesByPatternArgs{
		Regex:            regex,
		IncludeSysTables: includeSysTables,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvGetTableNamesByPattern() (value []*TTableName, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error82 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error83 error
		error83, err = error82.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error83
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTableNamesByPattern failed: out of sequence response")
		return
	}
	result := GetTableNamesByPatternResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get table names of tables in the given namespace
// @return the table names of the matching table
//
//
// Parameters:
//  - Name: The namesapce's name
func (client *THBaseServiceClient) GetTableNamesByNamespace(name string) (r []*TTableName, err error) {
	if err = client.sendGetTableNamesByNamespace(name); err != nil {
		return
	}
	return client.recvGetTableNamesByNamespace()
}

func (client *THBaseServiceClient) sendGetTableNamesByNamespace(name string) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("getTableNamesByNamespace", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := GetTableNamesByNamespaceArgs{
		Name: name,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvGetTableNamesByNamespace() (value []*TTableName, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error84 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error85 error
		error85, err = error84.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error85
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTableNamesByNamespace failed: out of sequence response")
		return
	}
	result := GetTableNamesByNamespaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Creates a new table with an initial set of empty regions defined by the specified split keys.
// The total number of regions created will be the number of split keys plus one. Synchronous
// operation.
//
//
// Parameters:
//  - Desc: table descriptor for table
//  - SplitKeys: rray of split keys for the initial regions of the table
func (client *THBaseServiceClient) CreateTable(desc *TTableDescriptor, splitKeys [][]byte) (err error) {
	if err = client.sendCreateTable(desc, splitKeys); err != nil {
		return
	}
	return client.recvCreateTable()
}

func (client *THBaseServiceClient) sendCreateTable(desc *TTableDescriptor, splitKeys [][]byte) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("createTable", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := CreateTableArgs{
		Desc:      desc,
		SplitKeys: splitKeys,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvCreateTable() (err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error86 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error87 error
		error87, err = error86.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error87
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "createTable failed: out of sequence response")
		return
	}
	result := CreateTableResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Deletes a table. Synchronous operation.
//
//
// Parameters:
//  - TableName: the tablename to delete
func (client *THBaseServiceClient) DeleteTable(tableName *TTableName) (err error) {
	if err = client.sendDeleteTable(tableName); err != nil {
		return
	}
	return client.recvDeleteTable()
}

func (client *THBaseServiceClient) sendDeleteTable(tableName *TTableName) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("deleteTable", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := DeleteTableArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvDeleteTable() (err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error88 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error89 error
		error89, err = error88.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error89
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteTable failed: out of sequence response")
		return
	}
	result := DeleteTableResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Truncate a table. Synchronous operation.
//
//
// Parameters:
//  - TableName: the tablename to truncate
//  - PreserveSplits: whether to  preserve previous splits
func (client *THBaseServiceClient) TruncateTable(tableName *TTableName, preserveSplits bool) (err error) {
	if err = client.sendTruncateTable(tableName, preserveSplits); err != nil {
		return
	}
	return client.recvTruncateTable()
}

func (client *THBaseServiceClient) sendTruncateTable(tableName *TTableName, preserveSplits bool) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("truncateTable", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := TruncateTableArgs{
		TableName:      tableName,
		PreserveSplits: preserveSplits,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvTruncateTable() (err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error90 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error91 error
		error91, err = error90.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error91
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "truncateTable failed: out of sequence response")
		return
	}
	result := TruncateTableResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Enalbe a table
//
//
// Parameters:
//  - TableName: the tablename to enable
func (client *THBaseServiceClient) EnableTable(tableName *TTableName) (err error) {
	if err = client.sendEnableTable(tableName); err != nil {
		return
	}
	return client.recvEnableTable()
}

func (client *THBaseServiceClient) sendEnableTable(tableName *TTableName) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("enableTable", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := EnableTableArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvEnableTable() (err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error92 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error93 error
		error93, err = error92.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error93
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "enableTable failed: out of sequence response")
		return
	}
	result := EnableTableResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Disable a table
//
//
// Parameters:
//  - TableName: the tablename to disable
func (client *THBaseServiceClient) DisableTable(tableName *TTableName) (err error) {
	if err = client.sendDisableTable(tableName); err != nil {
		return
	}
	return client.recvDisableTable()
}

func (client *THBaseServiceClient) sendDisableTable(tableName *TTableName) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("disableTable", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := DisableTableArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvDisableTable() (err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error94 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error95 error
		error95, err = error94.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error95
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "disableTable failed: out of sequence response")
		return
	}
	result := DisableTableResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

//
// @return true if table is enabled, false if not
//
//
// Parameters:
//  - TableName: the tablename to check
func (client *THBaseServiceClient) IsTableEnabled(tableName *TTableName) (r bool, err error) {
	if err = client.sendIsTableEnabled(tableName); err != nil {
		return
	}
	return client.recvIsTableEnabled()
}

func (client *THBaseServiceClient) sendIsTableEnabled(tableName *TTableName) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("isTableEnabled", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := IsTableEnabledArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvIsTableEnabled() (value bool, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error96 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error97 error
		error97, err = error96.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error97
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "isTableEnabled failed: out of sequence response")
		return
	}
	result := IsTableEnabledResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

//
// @return true if table is disabled, false if not
//
//
// Parameters:
//  - TableName: the tablename to check
func (client *THBaseServiceClient) IsTableDisabled(tableName *TTableName) (r bool, err error) {
	if err = client.sendIsTableDisabled(tableName); err != nil {
		return
	}
	return client.recvIsTableDisabled()
}

func (client *THBaseServiceClient) sendIsTableDisabled(tableName *TTableName) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("isTableDisabled", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := IsTableDisabledArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvIsTableDisabled() (value bool, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error98 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error99 error
		error99, err = error98.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error99
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "isTableDisabled failed: out of sequence response")
		return
	}
	result := IsTableDisabledResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

//
// @return true if table is available, false if not
//
//
// Parameters:
//  - TableName: the tablename to check
func (client *THBaseServiceClient) IsTableAvailable(tableName *TTableName) (r bool, err error) {
	if err = client.sendIsTableAvailable(tableName); err != nil {
		return
	}
	return client.recvIsTableAvailable()
}

func (client *THBaseServiceClient) sendIsTableAvailable(tableName *TTableName) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("isTableAvailable", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := IsTableAvailableArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvIsTableAvailable() (value bool, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error100 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error101 error
		error101, err = error100.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error101
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "isTableAvailable failed: out of sequence response")
		return
	}
	result := IsTableAvailableResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

//  * Use this api to check if the table has been created with the specified number of splitkeys
//  * which was used while creating the given table. Note : If this api is used after a table's
//  * region gets splitted, the api may return false.
//  *
//  * @return true if table is available, false if not
//  *
//  * @deprecated Since 2.2.0. Because the same method in Table interface has been deprecated
//  * since 2.0.0, we will remove it in 3.0.0 release.
//  * Use {@link #isTableAvailable(TTableName tableName)} instead
// *
//
// Parameters:
//  - TableName: the tablename to check
//  - SplitKeys: keys to check if the table has been created with all split keys
func (client *THBaseServiceClient) IsTableAvailableWithSplit(tableName *TTableName, splitKeys [][]byte) (r bool, err error) {
	if err = client.sendIsTableAvailableWithSplit(tableName, splitKeys); err != nil {
		return
	}
	return client.recvIsTableAvailableWithSplit()
}

func (client *THBaseServiceClient) sendIsTableAvailableWithSplit(tableName *TTableName, splitKeys [][]byte) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("isTableAvailableWithSplit", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := IsTableAvailableWithSplitArgs{
		TableName: tableName,
		SplitKeys: splitKeys,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvIsTableAvailableWithSplit() (value bool, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error102 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error103 error
		error103, err = error102.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error103
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "isTableAvailableWithSplit failed: out of sequence response")
		return
	}
	result := IsTableAvailableWithSplitResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Add a column family to an existing table. Synchronous operation.
//
//
// Parameters:
//  - TableName: the tablename to add column family to
//  - Column: column family descriptor of column family to be added
func (client *THBaseServiceClient) AddColumnFamily(tableName *TTableName, column *TColumnFamilyDescriptor) (err error) {
	if err = client.sendAddColumnFamily(tableName, column); err != nil {
		return
	}
	return client.recvAddColumnFamily()
}

func (client *THBaseServiceClient) sendAddColumnFamily(tableName *TTableName, column *TColumnFamilyDescriptor) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("addColumnFamily", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := AddColumnFamilyArgs{
		TableName: tableName,
		Column:    column,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvAddColumnFamily() (err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error104 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error105 error
		error105, err = error104.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error105
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "addColumnFamily failed: out of sequence response")
		return
	}
	result := AddColumnFamilyResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Delete a column family from a table. Synchronous operation.
//
//
// Parameters:
//  - TableName: the tablename to delete column family from
//  - Column: name of column family to be deleted
func (client *THBaseServiceClient) DeleteColumnFamily(tableName *TTableName, column []byte) (err error) {
	if err = client.sendDeleteColumnFamily(tableName, column); err != nil {
		return
	}
	return client.recvDeleteColumnFamily()
}

func (client *THBaseServiceClient) sendDeleteColumnFamily(tableName *TTableName, column []byte) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("deleteColumnFamily", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := DeleteColumnFamilyArgs{
		TableName: tableName,
		Column:    column,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvDeleteColumnFamily() (err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error106 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error107 error
		error107, err = error106.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error107
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteColumnFamily failed: out of sequence response")
		return
	}
	result := DeleteColumnFamilyResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Modify an existing column family on a table. Synchronous operation.
//
//
// Parameters:
//  - TableName: the tablename to modify column family
//  - Column: column family descriptor of column family to be modified
func (client *THBaseServiceClient) ModifyColumnFamily(tableName *TTableName, column *TColumnFamilyDescriptor) (err error) {
	if err = client.sendModifyColumnFamily(tableName, column); err != nil {
		return
	}
	return client.recvModifyColumnFamily()
}

func (client *THBaseServiceClient) sendModifyColumnFamily(tableName *TTableName, column *TColumnFamilyDescriptor) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("modifyColumnFamily", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := ModifyColumnFamilyArgs{
		TableName: tableName,
		Column:    column,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvModifyColumnFamily() (err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error108 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error109 error
		error109, err = error108.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error109
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "modifyColumnFamily failed: out of sequence response")
		return
	}
	result := ModifyColumnFamilyResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Modify an existing table
//
//
// Parameters:
//  - Desc: the descriptor of the table to modify
func (client *THBaseServiceClient) ModifyTable(desc *TTableDescriptor) (err error) {
	if err = client.sendModifyTable(desc); err != nil {
		return
	}
	return client.recvModifyTable()
}

func (client *THBaseServiceClient) sendModifyTable(desc *TTableDescriptor) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("modifyTable", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := ModifyTableArgs{
		Desc: desc,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvModifyTable() (err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error110 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error111 error
		error111, err = error110.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error111
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "modifyTable failed: out of sequence response")
		return
	}
	result := ModifyTableResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Create a new namespace. Blocks until namespace has been successfully created or an exception is
// thrown
//
//
// Parameters:
//  - NamespaceDesc: descriptor which describes the new namespace
func (client *THBaseServiceClient) CreateNamespace(namespaceDesc *TNamespaceDescriptor) (err error) {
	if err = client.sendCreateNamespace(namespaceDesc); err != nil {
		return
	}
	return client.recvCreateNamespace()
}

func (client *THBaseServiceClient) sendCreateNamespace(namespaceDesc *TNamespaceDescriptor) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("createNamespace", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := CreateNamespaceArgs{
		NamespaceDesc: namespaceDesc,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvCreateNamespace() (err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error112 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error113 error
		error113, err = error112.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error113
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "createNamespace failed: out of sequence response")
		return
	}
	result := CreateNamespaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Modify an existing namespace.  Blocks until namespace has been successfully modified or an
// exception is thrown
//
//
// Parameters:
//  - NamespaceDesc: descriptor which describes the new namespace
func (client *THBaseServiceClient) ModifyNamespace(namespaceDesc *TNamespaceDescriptor) (err error) {
	if err = client.sendModifyNamespace(namespaceDesc); err != nil {
		return
	}
	return client.recvModifyNamespace()
}

func (client *THBaseServiceClient) sendModifyNamespace(namespaceDesc *TNamespaceDescriptor) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("modifyNamespace", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := ModifyNamespaceArgs{
		NamespaceDesc: namespaceDesc,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvModifyNamespace() (err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error114 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error115 error
		error115, err = error114.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error115
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "modifyNamespace failed: out of sequence response")
		return
	}
	result := ModifyNamespaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Delete an existing namespace. Only empty namespaces (no tables) can be removed.
// Blocks until namespace has been successfully deleted or an
// exception is thrown.
//
//
// Parameters:
//  - Name: namespace name
func (client *THBaseServiceClient) DeleteNamespace(name string) (err error) {
	if err = client.sendDeleteNamespace(name); err != nil {
		return
	}
	return client.recvDeleteNamespace()
}

func (client *THBaseServiceClient) sendDeleteNamespace(name string) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("deleteNamespace", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := DeleteNamespaceArgs{
		Name: name,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvDeleteNamespace() (err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error116 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error117 error
		error117, err = error116.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error117
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteNamespace failed: out of sequence response")
		return
	}
	result := DeleteNamespaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Get a namespace descriptor by name.
// @retrun the descriptor
//
//
// Parameters:
//  - Name: name of namespace descriptor
func (client *THBaseServiceClient) GetNamespaceDescriptor(name string) (r *TNamespaceDescriptor, err error) {
	if err = client.sendGetNamespaceDescriptor(name); err != nil {
		return
	}
	return client.recvGetNamespaceDescriptor()
}

func (client *THBaseServiceClient) sendGetNamespaceDescriptor(name string) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("getNamespaceDescriptor", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := GetNamespaceDescriptorArgs{
		Name: name,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvGetNamespaceDescriptor() (value *TNamespaceDescriptor, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error118 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error119 error
		error119, err = error118.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error119
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getNamespaceDescriptor failed: out of sequence response")
		return
	}
	result := GetNamespaceDescriptorResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// @return all namespaces
//
func (client *THBaseServiceClient) ListNamespaceDescriptors() (r []*TNamespaceDescriptor, err error) {
	if err = client.sendListNamespaceDescriptors(); err != nil {
		return
	}
	return client.recvListNamespaceDescriptors()
}

func (client *THBaseServiceClient) sendListNamespaceDescriptors() (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("listNamespaceDescriptors", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := ListNamespaceDescriptorsArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvListNamespaceDescriptors() (value []*TNamespaceDescriptor, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error120 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error121 error
		error121, err = error120.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error121
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "listNamespaceDescriptors failed: out of sequence response")
		return
	}
	result := ListNamespaceDescriptorsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// @return all namespace names
//
func (client *THBaseServiceClient) ListNamespaces() (r []string, err error) {
	if err = client.sendListNamespaces(); err != nil {
		return
	}
	return client.recvListNamespaces()
}

func (client *THBaseServiceClient) sendListNamespaces() (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("listNamespaces", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := ListNamespacesArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvListNamespaces() (value []string, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error122 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error123 error
		error123, err = error122.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error123
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "listNamespaces failed: out of sequence response")
		return
	}
	result := ListNamespacesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get the type of this thrift server.
//
// @return the type of this thrift server
func (client *THBaseServiceClient) GetThriftServerType() (r TThriftServerType, err error) {
	if err = client.sendGetThriftServerType(); err != nil {
		return
	}
	return client.recvGetThriftServerType()
}

func (client *THBaseServiceClient) sendGetThriftServerType() (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("getThriftServerType", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := GetThriftServerTypeArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvGetThriftServerType() (value TThriftServerType, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error124 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error125 error
		error125, err = error124.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error125
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getThriftServerType failed: out of sequence response")
		return
	}
	result := GetThriftServerTypeResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Retrieves online slow RPC logs from the provided list of
// RegionServers
//
// @return online slowlog response list
// @throws TIOError if a remote or network exception occurs
//
// Parameters:
//  - ServerNames: @param serverNames Server names to get slowlog responses from
//  - LogQueryFilter: @param logQueryFilter filter to be used if provided
func (client *THBaseServiceClient) GetSlowLogResponses(serverNames map[*TServerName]bool, logQueryFilter *TLogQueryFilter) (r []*TOnlineLogRecord, err error) {
	if err = client.sendGetSlowLogResponses(serverNames, logQueryFilter); err != nil {
		return
	}
	return client.recvGetSlowLogResponses()
}

func (client *THBaseServiceClient) sendGetSlowLogResponses(serverNames map[*TServerName]bool, logQueryFilter *TLogQueryFilter) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("getSlowLogResponses", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := GetSlowLogResponsesArgs{
		ServerNames:    serverNames,
		LogQueryFilter: logQueryFilter,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvGetSlowLogResponses() (value []*TOnlineLogRecord, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error126 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error127 error
		error127, err = error126.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error127
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getSlowLogResponses failed: out of sequence response")
		return
	}
	result := GetSlowLogResponsesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Clears online slow/large RPC logs from the provided list of
// RegionServers
//
// @return List of booleans representing if online slowlog response buffer is cleaned
//   from each RegionServer
// @throws TIOError if a remote or network exception occurs
//
// Parameters:
//  - ServerNames: @param serverNames Set of Server names to clean slowlog responses from
func (client *THBaseServiceClient) ClearSlowLogResponses(serverNames map[*TServerName]bool) (r []bool, err error) {
	if err = client.sendClearSlowLogResponses(serverNames); err != nil {
		return
	}
	return client.recvClearSlowLogResponses()
}

func (client *THBaseServiceClient) sendClearSlowLogResponses(serverNames map[*TServerName]bool) (err error) {
	oprot := client.OutputProtocol
	if oprot == nil {
		oprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.OutputProtocol = oprot
	}
	client.SeqId++
	if err = oprot.WriteMessageBegin("clearSlowLogResponses", thrift.CALL, client.SeqId); err != nil {
		return
	}
	args := ClearSlowLogResponsesArgs{
		ServerNames: serverNames,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (client *THBaseServiceClient) recvClearSlowLogResponses() (value []bool, err error) {
	iprot := client.InputProtocol
	if iprot == nil {
		iprot = client.ProtocolFactory.GetProtocol(client.Transport)
		client.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error128 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error129 error
		error129, err = error128.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error129
		return
	}
	if client.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "clearSlowLogResponses failed: out of sequence response")
		return
	}
	result := ClearSlowLogResponsesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

type THBaseServiceProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      THBaseService
}

func (p *THBaseServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *THBaseServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *THBaseServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewTHBaseServiceProcessor(handler THBaseService) *THBaseServiceProcessor {

	self130 := &THBaseServiceProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self130.processorMap["exists"] = &tHBaseServiceProcessorExists{handler: handler}
	self130.processorMap["existsAll"] = &tHBaseServiceProcessorExistsAll{handler: handler}
	self130.processorMap["get"] = &tHBaseServiceProcessorGet{handler: handler}
	self130.processorMap["getMultiple"] = &tHBaseServiceProcessorGetMultiple{handler: handler}
	self130.processorMap["put"] = &tHBaseServiceProcessorPut{handler: handler}
	self130.processorMap["checkAndPut"] = &tHBaseServiceProcessorCheckAndPut{handler: handler}
	self130.processorMap["putMultiple"] = &tHBaseServiceProcessorPutMultiple{handler: handler}
	self130.processorMap["deleteSingle"] = &tHBaseServiceProcessorDeleteSingle{handler: handler}
	self130.processorMap["deleteMultiple"] = &tHBaseServiceProcessorDeleteMultiple{handler: handler}
	self130.processorMap["checkAndDelete"] = &tHBaseServiceProcessorCheckAndDelete{handler: handler}
	self130.processorMap["increment"] = &tHBaseServiceProcessorIncrement{handler: handler}
	self130.processorMap["append"] = &tHBaseServiceProcessorAppend{handler: handler}
	self130.processorMap["openScanner"] = &tHBaseServiceProcessorOpenScanner{handler: handler}
	self130.processorMap["getScannerRows"] = &tHBaseServiceProcessorGetScannerRows{handler: handler}
	self130.processorMap["closeScanner"] = &tHBaseServiceProcessorCloseScanner{handler: handler}
	self130.processorMap["mutateRow"] = &tHBaseServiceProcessorMutateRow{handler: handler}
	self130.processorMap["getScannerResults"] = &tHBaseServiceProcessorGetScannerResults{handler: handler}
	self130.processorMap["getRegionLocation"] = &tHBaseServiceProcessorGetRegionLocation{handler: handler}
	self130.processorMap["getAllRegionLocations"] = &tHBaseServiceProcessorGetAllRegionLocations{handler: handler}
	self130.processorMap["checkAndMutate"] = &tHBaseServiceProcessorCheckAndMutate{handler: handler}
	self130.processorMap["getTableDescriptor"] = &tHBaseServiceProcessorGetTableDescriptor{handler: handler}
	self130.processorMap["getTableDescriptors"] = &tHBaseServiceProcessorGetTableDescriptors{handler: handler}
	self130.processorMap["tableExists"] = &tHBaseServiceProcessorTableExists{handler: handler}
	self130.processorMap["getTableDescriptorsByPattern"] = &tHBaseServiceProcessorGetTableDescriptorsByPattern{handler: handler}
	self130.processorMap["getTableDescriptorsByNamespace"] = &tHBaseServiceProcessorGetTableDescriptorsByNamespace{handler: handler}
	self130.processorMap["getTableNamesByPattern"] = &tHBaseServiceProcessorGetTableNamesByPattern{handler: handler}
	self130.processorMap["getTableNamesByNamespace"] = &tHBaseServiceProcessorGetTableNamesByNamespace{handler: handler}
	self130.processorMap["createTable"] = &tHBaseServiceProcessorCreateTable{handler: handler}
	self130.processorMap["deleteTable"] = &tHBaseServiceProcessorDeleteTable{handler: handler}
	self130.processorMap["truncateTable"] = &tHBaseServiceProcessorTruncateTable{handler: handler}
	self130.processorMap["enableTable"] = &tHBaseServiceProcessorEnableTable{handler: handler}
	self130.processorMap["disableTable"] = &tHBaseServiceProcessorDisableTable{handler: handler}
	self130.processorMap["isTableEnabled"] = &tHBaseServiceProcessorIsTableEnabled{handler: handler}
	self130.processorMap["isTableDisabled"] = &tHBaseServiceProcessorIsTableDisabled{handler: handler}
	self130.processorMap["isTableAvailable"] = &tHBaseServiceProcessorIsTableAvailable{handler: handler}
	self130.processorMap["isTableAvailableWithSplit"] = &tHBaseServiceProcessorIsTableAvailableWithSplit{handler: handler}
	self130.processorMap["addColumnFamily"] = &tHBaseServiceProcessorAddColumnFamily{handler: handler}
	self130.processorMap["deleteColumnFamily"] = &tHBaseServiceProcessorDeleteColumnFamily{handler: handler}
	self130.processorMap["modifyColumnFamily"] = &tHBaseServiceProcessorModifyColumnFamily{handler: handler}
	self130.processorMap["modifyTable"] = &tHBaseServiceProcessorModifyTable{handler: handler}
	self130.processorMap["createNamespace"] = &tHBaseServiceProcessorCreateNamespace{handler: handler}
	self130.processorMap["modifyNamespace"] = &tHBaseServiceProcessorModifyNamespace{handler: handler}
	self130.processorMap["deleteNamespace"] = &tHBaseServiceProcessorDeleteNamespace{handler: handler}
	self130.processorMap["getNamespaceDescriptor"] = &tHBaseServiceProcessorGetNamespaceDescriptor{handler: handler}
	self130.processorMap["listNamespaceDescriptors"] = &tHBaseServiceProcessorListNamespaceDescriptors{handler: handler}
	self130.processorMap["listNamespaces"] = &tHBaseServiceProcessorListNamespaces{handler: handler}
	self130.processorMap["getThriftServerType"] = &tHBaseServiceProcessorGetThriftServerType{handler: handler}
	self130.processorMap["getSlowLogResponses"] = &tHBaseServiceProcessorGetSlowLogResponses{handler: handler}
	self130.processorMap["clearSlowLogResponses"] = &tHBaseServiceProcessorClearSlowLogResponses{handler: handler}
	return self130
}

func (p *THBaseServiceProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x131 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x131.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x131

}

type tHBaseServiceProcessorExists struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorExists) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ExistsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("exists", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ExistsResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.Exists(args.Table, args.Tget); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing exists: "+err2.Error())
			oprot.WriteMessageBegin("exists", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("exists", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorExistsAll struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorExistsAll) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ExistsAllArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("existsAll", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ExistsAllResult{}
	var retval []bool
	var err2 error
	if retval, err2 = p.handler.ExistsAll(args.Table, args.Tgets); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing existsAll: "+err2.Error())
			oprot.WriteMessageBegin("existsAll", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("existsAll", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGet struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGet) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetResult{}
	var retval *TResult_
	var err2 error
	if retval, err2 = p.handler.Get(args.Table, args.Tget); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get: "+err2.Error())
			oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("get", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetMultiple struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetMultiple) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetMultipleArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getMultiple", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetMultipleResult{}
	var retval []*TResult_
	var err2 error
	if retval, err2 = p.handler.GetMultiple(args.Table, args.Tgets); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getMultiple: "+err2.Error())
			oprot.WriteMessageBegin("getMultiple", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getMultiple", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorPut struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorPut) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := PutArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("put", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := PutResult{}
	var err2 error
	if err2 = p.handler.Put(args.Table, args.Tput); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing put: "+err2.Error())
			oprot.WriteMessageBegin("put", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("put", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorCheckAndPut struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCheckAndPut) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CheckAndPutArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("checkAndPut", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CheckAndPutResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.CheckAndPut(args.Table, args.Row, args.Family, args.Qualifier, args.Value, args.Tput); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkAndPut: "+err2.Error())
			oprot.WriteMessageBegin("checkAndPut", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("checkAndPut", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorPutMultiple struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorPutMultiple) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := PutMultipleArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("putMultiple", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := PutMultipleResult{}
	var err2 error
	if err2 = p.handler.PutMultiple(args.Table, args.Tputs); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing putMultiple: "+err2.Error())
			oprot.WriteMessageBegin("putMultiple", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("putMultiple", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorDeleteSingle struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteSingle) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DeleteSingleArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteSingle", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DeleteSingleResult{}
	var err2 error
	if err2 = p.handler.DeleteSingle(args.Table, args.Tdelete); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteSingle: "+err2.Error())
			oprot.WriteMessageBegin("deleteSingle", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteSingle", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorDeleteMultiple struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteMultiple) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DeleteMultipleArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteMultiple", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DeleteMultipleResult{}
	var retval []*TDelete
	var err2 error
	if retval, err2 = p.handler.DeleteMultiple(args.Table, args.Tdeletes); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteMultiple: "+err2.Error())
			oprot.WriteMessageBegin("deleteMultiple", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("deleteMultiple", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorCheckAndDelete struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCheckAndDelete) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CheckAndDeleteArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("checkAndDelete", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CheckAndDeleteResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.CheckAndDelete(args.Table, args.Row, args.Family, args.Qualifier, args.Value, args.Tdelete); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkAndDelete: "+err2.Error())
			oprot.WriteMessageBegin("checkAndDelete", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("checkAndDelete", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorIncrement struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorIncrement) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := IncrementArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("increment", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := IncrementResult{}
	var retval *TResult_
	var err2 error
	if retval, err2 = p.handler.Increment(args.Table, args.Tincrement); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing increment: "+err2.Error())
			oprot.WriteMessageBegin("increment", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("increment", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorAppend struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorAppend) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AppendArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("append", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AppendResult{}
	var retval *TResult_
	var err2 error
	if retval, err2 = p.handler.Append(args.Table, args.Tappend); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing append: "+err2.Error())
			oprot.WriteMessageBegin("append", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("append", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorOpenScanner struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorOpenScanner) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := OpenScannerArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("openScanner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := OpenScannerResult{}
	var retval int32
	var err2 error
	if retval, err2 = p.handler.OpenScanner(args.Table, args.Tscan); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing openScanner: "+err2.Error())
			oprot.WriteMessageBegin("openScanner", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("openScanner", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetScannerRows struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetScannerRows) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetScannerRowsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getScannerRows", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetScannerRowsResult{}
	var retval []*TResult_
	var err2 error
	if retval, err2 = p.handler.GetScannerRows(args.ScannerId, args.NumRows); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		case *TIllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getScannerRows: "+err2.Error())
			oprot.WriteMessageBegin("getScannerRows", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getScannerRows", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorCloseScanner struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCloseScanner) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CloseScannerArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("closeScanner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CloseScannerResult{}
	var err2 error
	if err2 = p.handler.CloseScanner(args.ScannerId); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		case *TIllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing closeScanner: "+err2.Error())
			oprot.WriteMessageBegin("closeScanner", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("closeScanner", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorMutateRow struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorMutateRow) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := MutateRowArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutateRow", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := MutateRowResult{}
	var err2 error
	if err2 = p.handler.MutateRow(args.Table, args.TrowMutations); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutateRow: "+err2.Error())
			oprot.WriteMessageBegin("mutateRow", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("mutateRow", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetScannerResults struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetScannerResults) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetScannerResultsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getScannerResults", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetScannerResultsResult{}
	var retval []*TResult_
	var err2 error
	if retval, err2 = p.handler.GetScannerResults(args.Table, args.Tscan, args.NumRows); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getScannerResults: "+err2.Error())
			oprot.WriteMessageBegin("getScannerResults", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getScannerResults", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetRegionLocation struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetRegionLocation) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetRegionLocationArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRegionLocation", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetRegionLocationResult{}
	var retval *THRegionLocation
	var err2 error
	if retval, err2 = p.handler.GetRegionLocation(args.Table, args.Row, args.Reload); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRegionLocation: "+err2.Error())
			oprot.WriteMessageBegin("getRegionLocation", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getRegionLocation", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetAllRegionLocations struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetAllRegionLocations) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetAllRegionLocationsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getAllRegionLocations", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetAllRegionLocationsResult{}
	var retval []*THRegionLocation
	var err2 error
	if retval, err2 = p.handler.GetAllRegionLocations(args.Table); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getAllRegionLocations: "+err2.Error())
			oprot.WriteMessageBegin("getAllRegionLocations", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getAllRegionLocations", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorCheckAndMutate struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCheckAndMutate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CheckAndMutateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("checkAndMutate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CheckAndMutateResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.CheckAndMutate(args.Table, args.Row, args.Family, args.Qualifier, args.CompareOp, args.Value, args.RowMutations); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkAndMutate: "+err2.Error())
			oprot.WriteMessageBegin("checkAndMutate", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("checkAndMutate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetTableDescriptor struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableDescriptor) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTableDescriptorArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTableDescriptor", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTableDescriptorResult{}
	var retval *TTableDescriptor
	var err2 error
	if retval, err2 = p.handler.GetTableDescriptor(args.Table); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableDescriptor: "+err2.Error())
			oprot.WriteMessageBegin("getTableDescriptor", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTableDescriptor", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetTableDescriptors struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableDescriptors) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTableDescriptorsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTableDescriptors", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTableDescriptorsResult{}
	var retval []*TTableDescriptor
	var err2 error
	if retval, err2 = p.handler.GetTableDescriptors(args.Tables); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableDescriptors: "+err2.Error())
			oprot.WriteMessageBegin("getTableDescriptors", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTableDescriptors", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorTableExists struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorTableExists) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TableExistsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("tableExists", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TableExistsResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.TableExists(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing tableExists: "+err2.Error())
			oprot.WriteMessageBegin("tableExists", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("tableExists", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetTableDescriptorsByPattern struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableDescriptorsByPattern) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTableDescriptorsByPatternArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTableDescriptorsByPattern", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTableDescriptorsByPatternResult{}
	var retval []*TTableDescriptor
	var err2 error
	if retval, err2 = p.handler.GetTableDescriptorsByPattern(args.Regex, args.IncludeSysTables); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableDescriptorsByPattern: "+err2.Error())
			oprot.WriteMessageBegin("getTableDescriptorsByPattern", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTableDescriptorsByPattern", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetTableDescriptorsByNamespace struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableDescriptorsByNamespace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTableDescriptorsByNamespaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTableDescriptorsByNamespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTableDescriptorsByNamespaceResult{}
	var retval []*TTableDescriptor
	var err2 error
	if retval, err2 = p.handler.GetTableDescriptorsByNamespace(args.Name); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableDescriptorsByNamespace: "+err2.Error())
			oprot.WriteMessageBegin("getTableDescriptorsByNamespace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTableDescriptorsByNamespace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetTableNamesByPattern struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableNamesByPattern) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTableNamesByPatternArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTableNamesByPattern", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTableNamesByPatternResult{}
	var retval []*TTableName
	var err2 error
	if retval, err2 = p.handler.GetTableNamesByPattern(args.Regex, args.IncludeSysTables); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableNamesByPattern: "+err2.Error())
			oprot.WriteMessageBegin("getTableNamesByPattern", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTableNamesByPattern", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetTableNamesByNamespace struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetTableNamesByNamespace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTableNamesByNamespaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTableNamesByNamespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTableNamesByNamespaceResult{}
	var retval []*TTableName
	var err2 error
	if retval, err2 = p.handler.GetTableNamesByNamespace(args.Name); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableNamesByNamespace: "+err2.Error())
			oprot.WriteMessageBegin("getTableNamesByNamespace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTableNamesByNamespace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorCreateTable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCreateTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CreateTableArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("createTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CreateTableResult{}
	var err2 error
	if err2 = p.handler.CreateTable(args.Desc, args.SplitKeys); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createTable: "+err2.Error())
			oprot.WriteMessageBegin("createTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("createTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorDeleteTable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DeleteTableArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DeleteTableResult{}
	var err2 error
	if err2 = p.handler.DeleteTable(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteTable: "+err2.Error())
			oprot.WriteMessageBegin("deleteTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorTruncateTable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorTruncateTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TruncateTableArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("truncateTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TruncateTableResult{}
	var err2 error
	if err2 = p.handler.TruncateTable(args.TableName, args.PreserveSplits); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing truncateTable: "+err2.Error())
			oprot.WriteMessageBegin("truncateTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("truncateTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorEnableTable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorEnableTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := EnableTableArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("enableTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := EnableTableResult{}
	var err2 error
	if err2 = p.handler.EnableTable(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing enableTable: "+err2.Error())
			oprot.WriteMessageBegin("enableTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("enableTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorDisableTable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDisableTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DisableTableArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("disableTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DisableTableResult{}
	var err2 error
	if err2 = p.handler.DisableTable(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing disableTable: "+err2.Error())
			oprot.WriteMessageBegin("disableTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("disableTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorIsTableEnabled struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorIsTableEnabled) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := IsTableEnabledArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("isTableEnabled", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := IsTableEnabledResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.IsTableEnabled(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableEnabled: "+err2.Error())
			oprot.WriteMessageBegin("isTableEnabled", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("isTableEnabled", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorIsTableDisabled struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorIsTableDisabled) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := IsTableDisabledArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("isTableDisabled", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := IsTableDisabledResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.IsTableDisabled(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableDisabled: "+err2.Error())
			oprot.WriteMessageBegin("isTableDisabled", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("isTableDisabled", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorIsTableAvailable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorIsTableAvailable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := IsTableAvailableArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("isTableAvailable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := IsTableAvailableResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.IsTableAvailable(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableAvailable: "+err2.Error())
			oprot.WriteMessageBegin("isTableAvailable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("isTableAvailable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorIsTableAvailableWithSplit struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorIsTableAvailableWithSplit) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := IsTableAvailableWithSplitArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("isTableAvailableWithSplit", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := IsTableAvailableWithSplitResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.IsTableAvailableWithSplit(args.TableName, args.SplitKeys); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableAvailableWithSplit: "+err2.Error())
			oprot.WriteMessageBegin("isTableAvailableWithSplit", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("isTableAvailableWithSplit", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorAddColumnFamily struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorAddColumnFamily) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AddColumnFamilyArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("addColumnFamily", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AddColumnFamilyResult{}
	var err2 error
	if err2 = p.handler.AddColumnFamily(args.TableName, args.Column); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing addColumnFamily: "+err2.Error())
			oprot.WriteMessageBegin("addColumnFamily", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("addColumnFamily", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorDeleteColumnFamily struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteColumnFamily) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DeleteColumnFamilyArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteColumnFamily", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DeleteColumnFamilyResult{}
	var err2 error
	if err2 = p.handler.DeleteColumnFamily(args.TableName, args.Column); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteColumnFamily: "+err2.Error())
			oprot.WriteMessageBegin("deleteColumnFamily", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteColumnFamily", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorModifyColumnFamily struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorModifyColumnFamily) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ModifyColumnFamilyArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("modifyColumnFamily", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ModifyColumnFamilyResult{}
	var err2 error
	if err2 = p.handler.ModifyColumnFamily(args.TableName, args.Column); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing modifyColumnFamily: "+err2.Error())
			oprot.WriteMessageBegin("modifyColumnFamily", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("modifyColumnFamily", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorModifyTable struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorModifyTable) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ModifyTableArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("modifyTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ModifyTableResult{}
	var err2 error
	if err2 = p.handler.ModifyTable(args.Desc); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing modifyTable: "+err2.Error())
			oprot.WriteMessageBegin("modifyTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("modifyTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorCreateNamespace struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCreateNamespace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CreateNamespaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("createNamespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CreateNamespaceResult{}
	var err2 error
	if err2 = p.handler.CreateNamespace(args.NamespaceDesc); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createNamespace: "+err2.Error())
			oprot.WriteMessageBegin("createNamespace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("createNamespace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorModifyNamespace struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorModifyNamespace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ModifyNamespaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("modifyNamespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ModifyNamespaceResult{}
	var err2 error
	if err2 = p.handler.ModifyNamespace(args.NamespaceDesc); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing modifyNamespace: "+err2.Error())
			oprot.WriteMessageBegin("modifyNamespace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("modifyNamespace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorDeleteNamespace struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteNamespace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DeleteNamespaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteNamespace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DeleteNamespaceResult{}
	var err2 error
	if err2 = p.handler.DeleteNamespace(args.Name); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteNamespace: "+err2.Error())
			oprot.WriteMessageBegin("deleteNamespace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteNamespace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetNamespaceDescriptor struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetNamespaceDescriptor) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetNamespaceDescriptorArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getNamespaceDescriptor", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetNamespaceDescriptorResult{}
	var retval *TNamespaceDescriptor
	var err2 error
	if retval, err2 = p.handler.GetNamespaceDescriptor(args.Name); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getNamespaceDescriptor: "+err2.Error())
			oprot.WriteMessageBegin("getNamespaceDescriptor", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getNamespaceDescriptor", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorListNamespaceDescriptors struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorListNamespaceDescriptors) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ListNamespaceDescriptorsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("listNamespaceDescriptors", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ListNamespaceDescriptorsResult{}
	var retval []*TNamespaceDescriptor
	var err2 error
	if retval, err2 = p.handler.ListNamespaceDescriptors(); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listNamespaceDescriptors: "+err2.Error())
			oprot.WriteMessageBegin("listNamespaceDescriptors", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("listNamespaceDescriptors", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorListNamespaces struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorListNamespaces) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ListNamespacesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("listNamespaces", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ListNamespacesResult{}
	var retval []string
	var err2 error
	if retval, err2 = p.handler.ListNamespaces(); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listNamespaces: "+err2.Error())
			oprot.WriteMessageBegin("listNamespaces", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("listNamespaces", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetThriftServerType struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetThriftServerType) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetThriftServerTypeArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getThriftServerType", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetThriftServerTypeResult{}
	var retval TThriftServerType
	var err2 error
	if retval, err2 = p.handler.GetThriftServerType(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getThriftServerType: "+err2.Error())
		oprot.WriteMessageBegin("getThriftServerType", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("getThriftServerType", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetSlowLogResponses struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetSlowLogResponses) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetSlowLogResponsesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getSlowLogResponses", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetSlowLogResponsesResult{}
	var retval []*TOnlineLogRecord
	var err2 error
	if retval, err2 = p.handler.GetSlowLogResponses(args.ServerNames, args.LogQueryFilter); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getSlowLogResponses: "+err2.Error())
			oprot.WriteMessageBegin("getSlowLogResponses", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getSlowLogResponses", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorClearSlowLogResponses struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorClearSlowLogResponses) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ClearSlowLogResponsesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("clearSlowLogResponses", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ClearSlowLogResponsesResult{}
	var retval []bool
	var err2 error
	if retval, err2 = p.handler.ClearSlowLogResponses(args.ServerNames); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing clearSlowLogResponses: "+err2.Error())
			oprot.WriteMessageBegin("clearSlowLogResponses", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("clearSlowLogResponses", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type ExistsArgs struct {
	Table []byte `thrift:"table,1,required" json:"table"`
	Tget  *TGet  `thrift:"tget,2,required" json:"tget"`
}

func NewExistsArgs() *ExistsArgs {
	return &ExistsArgs{}
}

func (p *ExistsArgs) GetTable() []byte {
	return p.Table
}

var ExistsArgs_Tget_DEFAULT *TGet

func (p *ExistsArgs) GetTget() *TGet {
	if !p.IsSetTget() {
		return ExistsArgs_Tget_DEFAULT
	}
	return p.Tget
}
func (p *ExistsArgs) IsSetTget() bool {
	return p.Tget != nil
}

func (p *ExistsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExistsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *ExistsArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Tget = &TGet{}
	if err := p.Tget.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Tget, err)
	}
	return nil
}

func (p *ExistsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("exists_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExistsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *ExistsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tget", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:tget: %s", p, err)
	}
	if err := p.Tget.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Tget, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:tget: %s", p, err)
	}
	return err
}

func (p *ExistsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExistsArgs(%+v)", *p)
}

type ExistsResult struct {
	Success *bool     `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewExistsResult() *ExistsResult {
	return &ExistsResult{}
}

var ExistsResult_Success_DEFAULT bool

func (p *ExistsResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return ExistsResult_Success_DEFAULT
	}
	return *p.Success
}

var ExistsResult_Io_DEFAULT *TIOError

func (p *ExistsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return ExistsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *ExistsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ExistsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *ExistsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExistsResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *ExistsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ExistsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("exists_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExistsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ExistsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ExistsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExistsResult(%+v)", *p)
}

type ExistsAllArgs struct {
	Table []byte  `thrift:"table,1,required" json:"table"`
	Tgets []*TGet `thrift:"tgets,2,required" json:"tgets"`
}

func NewExistsAllArgs() *ExistsAllArgs {
	return &ExistsAllArgs{}
}

func (p *ExistsAllArgs) GetTable() []byte {
	return p.Table
}

func (p *ExistsAllArgs) GetTgets() []*TGet {
	return p.Tgets
}
func (p *ExistsAllArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExistsAllArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *ExistsAllArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TGet, 0, size)
	p.Tgets = tSlice
	for i := 0; i < size; i++ {
		_elem132 := &TGet{}
		if err := _elem132.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem132, err)
		}
		p.Tgets = append(p.Tgets, _elem132)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ExistsAllArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("existsAll_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExistsAllArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *ExistsAllArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tgets", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:tgets: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Tgets)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Tgets {
		if err := v.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", v, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:tgets: %s", p, err)
	}
	return err
}

func (p *ExistsAllArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExistsAllArgs(%+v)", *p)
}

type ExistsAllResult struct {
	Success []bool    `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewExistsAllResult() *ExistsAllResult {
	return &ExistsAllResult{}
}

var ExistsAllResult_Success_DEFAULT []bool

func (p *ExistsAllResult) GetSuccess() []bool {
	return p.Success
}

var ExistsAllResult_Io_DEFAULT *TIOError

func (p *ExistsAllResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return ExistsAllResult_Io_DEFAULT
	}
	return p.Io
}
func (p *ExistsAllResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ExistsAllResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *ExistsAllResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExistsAllResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]bool, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem133 bool
		if v, err := iprot.ReadBool(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem133 = v
		}
		p.Success = append(p.Success, _elem133)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ExistsAllResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ExistsAllResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("existsAll_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExistsAllResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BOOL, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := oprot.WriteBool(bool(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ExistsAllResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ExistsAllResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExistsAllResult(%+v)", *p)
}

type GetArgs struct {
	Table []byte `thrift:"table,1,required" json:"table"`
	Tget  *TGet  `thrift:"tget,2,required" json:"tget"`
}

func NewGetArgs() *GetArgs {
	return &GetArgs{}
}

func (p *GetArgs) GetTable() []byte {
	return p.Table
}

var GetArgs_Tget_DEFAULT *TGet

func (p *GetArgs) GetTget() *TGet {
	if !p.IsSetTget() {
		return GetArgs_Tget_DEFAULT
	}
	return p.Tget
}
func (p *GetArgs) IsSetTget() bool {
	return p.Tget != nil
}

func (p *GetArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *GetArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Tget = &TGet{}
	if err := p.Tget.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Tget, err)
	}
	return nil
}

func (p *GetArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *GetArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tget", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:tget: %s", p, err)
	}
	if err := p.Tget.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Tget, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:tget: %s", p, err)
	}
	return err
}

func (p *GetArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetArgs(%+v)", *p)
}

type GetResult struct {
	Success *TResult_ `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewGetResult() *GetResult {
	return &GetResult{}
}

var GetResult_Success_DEFAULT *TResult_

func (p *GetResult) GetSuccess() *TResult_ {
	if !p.IsSetSuccess() {
		return GetResult_Success_DEFAULT
	}
	return p.Success
}

var GetResult_Io_DEFAULT *TIOError

func (p *GetResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return GetResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResult(%+v)", *p)
}

type GetMultipleArgs struct {
	Table []byte  `thrift:"table,1,required" json:"table"`
	Tgets []*TGet `thrift:"tgets,2,required" json:"tgets"`
}

func NewGetMultipleArgs() *GetMultipleArgs {
	return &GetMultipleArgs{}
}

func (p *GetMultipleArgs) GetTable() []byte {
	return p.Table
}

func (p *GetMultipleArgs) GetTgets() []*TGet {
	return p.Tgets
}
func (p *GetMultipleArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetMultipleArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *GetMultipleArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TGet, 0, size)
	p.Tgets = tSlice
	for i := 0; i < size; i++ {
		_elem134 := &TGet{}
		if err := _elem134.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem134, err)
		}
		p.Tgets = append(p.Tgets, _elem134)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetMultipleArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getMultiple_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetMultipleArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *GetMultipleArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tgets", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:tgets: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Tgets)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Tgets {
		if err := v.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", v, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:tgets: %s", p, err)
	}
	return err
}

func (p *GetMultipleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetMultipleArgs(%+v)", *p)
}

type GetMultipleResult struct {
	Success []*TResult_ `thrift:"success,0" json:"success"`
	Io      *TIOError   `thrift:"io,1" json:"io"`
}

func NewGetMultipleResult() *GetMultipleResult {
	return &GetMultipleResult{}
}

var GetMultipleResult_Success_DEFAULT []*TResult_

func (p *GetMultipleResult) GetSuccess() []*TResult_ {
	return p.Success
}

var GetMultipleResult_Io_DEFAULT *TIOError

func (p *GetMultipleResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return GetMultipleResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetMultipleResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetMultipleResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetMultipleResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetMultipleResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem135 := &TResult_{}
		if err := _elem135.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem135, err)
		}
		p.Success = append(p.Success, _elem135)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetMultipleResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetMultipleResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getMultiple_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetMultipleResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetMultipleResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetMultipleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetMultipleResult(%+v)", *p)
}

type PutArgs struct {
	Table []byte `thrift:"table,1,required" json:"table"`
	Tput  *TPut  `thrift:"tput,2,required" json:"tput"`
}

func NewPutArgs() *PutArgs {
	return &PutArgs{}
}

func (p *PutArgs) GetTable() []byte {
	return p.Table
}

var PutArgs_Tput_DEFAULT *TPut

func (p *PutArgs) GetTput() *TPut {
	if !p.IsSetTput() {
		return PutArgs_Tput_DEFAULT
	}
	return p.Tput
}
func (p *PutArgs) IsSetTput() bool {
	return p.Tput != nil
}

func (p *PutArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PutArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *PutArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Tput = &TPut{}
	if err := p.Tput.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Tput, err)
	}
	return nil
}

func (p *PutArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("put_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PutArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *PutArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tput", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:tput: %s", p, err)
	}
	if err := p.Tput.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Tput, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:tput: %s", p, err)
	}
	return err
}

func (p *PutArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PutArgs(%+v)", *p)
}

type PutResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewPutResult() *PutResult {
	return &PutResult{}
}

var PutResult_Io_DEFAULT *TIOError

func (p *PutResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return PutResult_Io_DEFAULT
	}
	return p.Io
}
func (p *PutResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *PutResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PutResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *PutResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("put_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PutResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *PutResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PutResult(%+v)", *p)
}

type CheckAndPutArgs struct {
	Table     []byte `thrift:"table,1,required" json:"table"`
	Row       []byte `thrift:"row,2,required" json:"row"`
	Family    []byte `thrift:"family,3,required" json:"family"`
	Qualifier []byte `thrift:"qualifier,4,required" json:"qualifier"`
	Value     []byte `thrift:"value,5" json:"value"`
	Tput      *TPut  `thrift:"tput,6,required" json:"tput"`
}

func NewCheckAndPutArgs() *CheckAndPutArgs {
	return &CheckAndPutArgs{}
}

func (p *CheckAndPutArgs) GetTable() []byte {
	return p.Table
}

func (p *CheckAndPutArgs) GetRow() []byte {
	return p.Row
}

func (p *CheckAndPutArgs) GetFamily() []byte {
	return p.Family
}

func (p *CheckAndPutArgs) GetQualifier() []byte {
	return p.Qualifier
}

func (p *CheckAndPutArgs) GetValue() []byte {
	return p.Value
}

var CheckAndPutArgs_Tput_DEFAULT *TPut

func (p *CheckAndPutArgs) GetTput() *TPut {
	if !p.IsSetTput() {
		return CheckAndPutArgs_Tput_DEFAULT
	}
	return p.Tput
}
func (p *CheckAndPutArgs) IsSetTput() bool {
	return p.Tput != nil
}

func (p *CheckAndPutArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Family = v
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Qualifier = v
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField6(iprot thrift.TProtocol) error {
	p.Tput = &TPut{}
	if err := p.Tput.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Tput, err)
	}
	return nil
}

func (p *CheckAndPutArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndPut_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckAndPutArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *CheckAndPutArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *CheckAndPutArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("family", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:family: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Family); err != nil {
		return fmt.Errorf("%T.family (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:family: %s", p, err)
	}
	return err
}

func (p *CheckAndPutArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("qualifier", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:qualifier: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Qualifier); err != nil {
		return fmt.Errorf("%T.qualifier (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:qualifier: %s", p, err)
	}
	return err
}

func (p *CheckAndPutArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.STRING, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:value: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Value); err != nil {
		return fmt.Errorf("%T.value (5) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:value: %s", p, err)
	}
	return err
}

func (p *CheckAndPutArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tput", thrift.STRUCT, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:tput: %s", p, err)
	}
	if err := p.Tput.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Tput, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 6:tput: %s", p, err)
	}
	return err
}

func (p *CheckAndPutArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckAndPutArgs(%+v)", *p)
}

type CheckAndPutResult struct {
	Success *bool     `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewCheckAndPutResult() *CheckAndPutResult {
	return &CheckAndPutResult{}
}

var CheckAndPutResult_Success_DEFAULT bool

func (p *CheckAndPutResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return CheckAndPutResult_Success_DEFAULT
	}
	return *p.Success
}

var CheckAndPutResult_Io_DEFAULT *TIOError

func (p *CheckAndPutResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return CheckAndPutResult_Io_DEFAULT
	}
	return p.Io
}
func (p *CheckAndPutResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CheckAndPutResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *CheckAndPutResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckAndPutResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CheckAndPutResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *CheckAndPutResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndPut_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckAndPutResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndPutResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndPutResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckAndPutResult(%+v)", *p)
}

type PutMultipleArgs struct {
	Table []byte  `thrift:"table,1,required" json:"table"`
	Tputs []*TPut `thrift:"tputs,2,required" json:"tputs"`
}

func NewPutMultipleArgs() *PutMultipleArgs {
	return &PutMultipleArgs{}
}

func (p *PutMultipleArgs) GetTable() []byte {
	return p.Table
}

func (p *PutMultipleArgs) GetTputs() []*TPut {
	return p.Tputs
}
func (p *PutMultipleArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PutMultipleArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *PutMultipleArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TPut, 0, size)
	p.Tputs = tSlice
	for i := 0; i < size; i++ {
		_elem136 := &TPut{}
		if err := _elem136.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem136, err)
		}
		p.Tputs = append(p.Tputs, _elem136)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *PutMultipleArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("putMultiple_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PutMultipleArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *PutMultipleArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tputs", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:tputs: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Tputs)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Tputs {
		if err := v.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", v, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:tputs: %s", p, err)
	}
	return err
}

func (p *PutMultipleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PutMultipleArgs(%+v)", *p)
}

type PutMultipleResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewPutMultipleResult() *PutMultipleResult {
	return &PutMultipleResult{}
}

var PutMultipleResult_Io_DEFAULT *TIOError

func (p *PutMultipleResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return PutMultipleResult_Io_DEFAULT
	}
	return p.Io
}
func (p *PutMultipleResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *PutMultipleResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PutMultipleResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *PutMultipleResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("putMultiple_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PutMultipleResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *PutMultipleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PutMultipleResult(%+v)", *p)
}

type DeleteSingleArgs struct {
	Table   []byte   `thrift:"table,1,required" json:"table"`
	Tdelete *TDelete `thrift:"tdelete,2,required" json:"tdelete"`
}

func NewDeleteSingleArgs() *DeleteSingleArgs {
	return &DeleteSingleArgs{}
}

func (p *DeleteSingleArgs) GetTable() []byte {
	return p.Table
}

var DeleteSingleArgs_Tdelete_DEFAULT *TDelete

func (p *DeleteSingleArgs) GetTdelete() *TDelete {
	if !p.IsSetTdelete() {
		return DeleteSingleArgs_Tdelete_DEFAULT
	}
	return p.Tdelete
}
func (p *DeleteSingleArgs) IsSetTdelete() bool {
	return p.Tdelete != nil
}

func (p *DeleteSingleArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteSingleArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *DeleteSingleArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Tdelete = &TDelete{
		DeleteType: 1,
	}
	if err := p.Tdelete.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Tdelete, err)
	}
	return nil
}

func (p *DeleteSingleArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteSingle_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteSingleArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *DeleteSingleArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tdelete", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:tdelete: %s", p, err)
	}
	if err := p.Tdelete.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Tdelete, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:tdelete: %s", p, err)
	}
	return err
}

func (p *DeleteSingleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteSingleArgs(%+v)", *p)
}

type DeleteSingleResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewDeleteSingleResult() *DeleteSingleResult {
	return &DeleteSingleResult{}
}

var DeleteSingleResult_Io_DEFAULT *TIOError

func (p *DeleteSingleResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return DeleteSingleResult_Io_DEFAULT
	}
	return p.Io
}
func (p *DeleteSingleResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *DeleteSingleResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteSingleResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteSingleResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteSingle_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteSingleResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteSingleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteSingleResult(%+v)", *p)
}

type DeleteMultipleArgs struct {
	Table    []byte     `thrift:"table,1,required" json:"table"`
	Tdeletes []*TDelete `thrift:"tdeletes,2,required" json:"tdeletes"`
}

func NewDeleteMultipleArgs() *DeleteMultipleArgs {
	return &DeleteMultipleArgs{}
}

func (p *DeleteMultipleArgs) GetTable() []byte {
	return p.Table
}

func (p *DeleteMultipleArgs) GetTdeletes() []*TDelete {
	return p.Tdeletes
}
func (p *DeleteMultipleArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteMultipleArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *DeleteMultipleArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TDelete, 0, size)
	p.Tdeletes = tSlice
	for i := 0; i < size; i++ {
		_elem137 := &TDelete{
			DeleteType: 1,
		}
		if err := _elem137.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem137, err)
		}
		p.Tdeletes = append(p.Tdeletes, _elem137)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *DeleteMultipleArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteMultiple_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteMultipleArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *DeleteMultipleArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tdeletes", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:tdeletes: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Tdeletes)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Tdeletes {
		if err := v.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", v, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:tdeletes: %s", p, err)
	}
	return err
}

func (p *DeleteMultipleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteMultipleArgs(%+v)", *p)
}

type DeleteMultipleResult struct {
	Success []*TDelete `thrift:"success,0" json:"success"`
	Io      *TIOError  `thrift:"io,1" json:"io"`
}

func NewDeleteMultipleResult() *DeleteMultipleResult {
	return &DeleteMultipleResult{}
}

var DeleteMultipleResult_Success_DEFAULT []*TDelete

func (p *DeleteMultipleResult) GetSuccess() []*TDelete {
	return p.Success
}

var DeleteMultipleResult_Io_DEFAULT *TIOError

func (p *DeleteMultipleResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return DeleteMultipleResult_Io_DEFAULT
	}
	return p.Io
}
func (p *DeleteMultipleResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteMultipleResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *DeleteMultipleResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteMultipleResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TDelete, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem138 := &TDelete{
			DeleteType: 1,
		}
		if err := _elem138.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem138, err)
		}
		p.Success = append(p.Success, _elem138)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *DeleteMultipleResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteMultipleResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteMultiple_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteMultipleResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DeleteMultipleResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteMultipleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteMultipleResult(%+v)", *p)
}

type CheckAndDeleteArgs struct {
	Table     []byte   `thrift:"table,1,required" json:"table"`
	Row       []byte   `thrift:"row,2,required" json:"row"`
	Family    []byte   `thrift:"family,3,required" json:"family"`
	Qualifier []byte   `thrift:"qualifier,4,required" json:"qualifier"`
	Value     []byte   `thrift:"value,5" json:"value"`
	Tdelete   *TDelete `thrift:"tdelete,6,required" json:"tdelete"`
}

func NewCheckAndDeleteArgs() *CheckAndDeleteArgs {
	return &CheckAndDeleteArgs{}
}

func (p *CheckAndDeleteArgs) GetTable() []byte {
	return p.Table
}

func (p *CheckAndDeleteArgs) GetRow() []byte {
	return p.Row
}

func (p *CheckAndDeleteArgs) GetFamily() []byte {
	return p.Family
}

func (p *CheckAndDeleteArgs) GetQualifier() []byte {
	return p.Qualifier
}

func (p *CheckAndDeleteArgs) GetValue() []byte {
	return p.Value
}

var CheckAndDeleteArgs_Tdelete_DEFAULT *TDelete

func (p *CheckAndDeleteArgs) GetTdelete() *TDelete {
	if !p.IsSetTdelete() {
		return CheckAndDeleteArgs_Tdelete_DEFAULT
	}
	return p.Tdelete
}
func (p *CheckAndDeleteArgs) IsSetTdelete() bool {
	return p.Tdelete != nil
}

func (p *CheckAndDeleteArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckAndDeleteArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *CheckAndDeleteArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *CheckAndDeleteArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Family = v
	}
	return nil
}

func (p *CheckAndDeleteArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Qualifier = v
	}
	return nil
}

func (p *CheckAndDeleteArgs) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *CheckAndDeleteArgs) ReadField6(iprot thrift.TProtocol) error {
	p.Tdelete = &TDelete{
		DeleteType: 1,
	}
	if err := p.Tdelete.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Tdelete, err)
	}
	return nil
}

func (p *CheckAndDeleteArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndDelete_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckAndDeleteArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *CheckAndDeleteArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *CheckAndDeleteArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("family", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:family: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Family); err != nil {
		return fmt.Errorf("%T.family (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:family: %s", p, err)
	}
	return err
}

func (p *CheckAndDeleteArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("qualifier", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:qualifier: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Qualifier); err != nil {
		return fmt.Errorf("%T.qualifier (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:qualifier: %s", p, err)
	}
	return err
}

func (p *CheckAndDeleteArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.STRING, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:value: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Value); err != nil {
		return fmt.Errorf("%T.value (5) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:value: %s", p, err)
	}
	return err
}

func (p *CheckAndDeleteArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tdelete", thrift.STRUCT, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:tdelete: %s", p, err)
	}
	if err := p.Tdelete.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Tdelete, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 6:tdelete: %s", p, err)
	}
	return err
}

func (p *CheckAndDeleteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckAndDeleteArgs(%+v)", *p)
}

type CheckAndDeleteResult struct {
	Success *bool     `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewCheckAndDeleteResult() *CheckAndDeleteResult {
	return &CheckAndDeleteResult{}
}

var CheckAndDeleteResult_Success_DEFAULT bool

func (p *CheckAndDeleteResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return CheckAndDeleteResult_Success_DEFAULT
	}
	return *p.Success
}

var CheckAndDeleteResult_Io_DEFAULT *TIOError

func (p *CheckAndDeleteResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return CheckAndDeleteResult_Io_DEFAULT
	}
	return p.Io
}
func (p *CheckAndDeleteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CheckAndDeleteResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *CheckAndDeleteResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckAndDeleteResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CheckAndDeleteResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *CheckAndDeleteResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndDelete_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckAndDeleteResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndDeleteResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndDeleteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckAndDeleteResult(%+v)", *p)
}

type IncrementArgs struct {
	Table      []byte      `thrift:"table,1,required" json:"table"`
	Tincrement *TIncrement `thrift:"tincrement,2,required" json:"tincrement"`
}

func NewIncrementArgs() *IncrementArgs {
	return &IncrementArgs{}
}

func (p *IncrementArgs) GetTable() []byte {
	return p.Table
}

var IncrementArgs_Tincrement_DEFAULT *TIncrement

func (p *IncrementArgs) GetTincrement() *TIncrement {
	if !p.IsSetTincrement() {
		return IncrementArgs_Tincrement_DEFAULT
	}
	return p.Tincrement
}
func (p *IncrementArgs) IsSetTincrement() bool {
	return p.Tincrement != nil
}

func (p *IncrementArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *IncrementArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Tincrement = &TIncrement{}
	if err := p.Tincrement.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Tincrement, err)
	}
	return nil
}

func (p *IncrementArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("increment_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *IncrementArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tincrement", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:tincrement: %s", p, err)
	}
	if err := p.Tincrement.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Tincrement, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:tincrement: %s", p, err)
	}
	return err
}

func (p *IncrementArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementArgs(%+v)", *p)
}

type IncrementResult struct {
	Success *TResult_ `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewIncrementResult() *IncrementResult {
	return &IncrementResult{}
}

var IncrementResult_Success_DEFAULT *TResult_

func (p *IncrementResult) GetSuccess() *TResult_ {
	if !p.IsSetSuccess() {
		return IncrementResult_Success_DEFAULT
	}
	return p.Success
}

var IncrementResult_Io_DEFAULT *TIOError

func (p *IncrementResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return IncrementResult_Io_DEFAULT
	}
	return p.Io
}
func (p *IncrementResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *IncrementResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *IncrementResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *IncrementResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *IncrementResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("increment_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *IncrementResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *IncrementResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementResult(%+v)", *p)
}

type AppendArgs struct {
	Table   []byte   `thrift:"table,1,required" json:"table"`
	Tappend *TAppend `thrift:"tappend,2,required" json:"tappend"`
}

func NewAppendArgs() *AppendArgs {
	return &AppendArgs{}
}

func (p *AppendArgs) GetTable() []byte {
	return p.Table
}

var AppendArgs_Tappend_DEFAULT *TAppend

func (p *AppendArgs) GetTappend() *TAppend {
	if !p.IsSetTappend() {
		return AppendArgs_Tappend_DEFAULT
	}
	return p.Tappend
}
func (p *AppendArgs) IsSetTappend() bool {
	return p.Tappend != nil
}

func (p *AppendArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AppendArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *AppendArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Tappend = &TAppend{}
	if err := p.Tappend.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Tappend, err)
	}
	return nil
}

func (p *AppendArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("append_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AppendArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *AppendArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tappend", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:tappend: %s", p, err)
	}
	if err := p.Tappend.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Tappend, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:tappend: %s", p, err)
	}
	return err
}

func (p *AppendArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AppendArgs(%+v)", *p)
}

type AppendResult struct {
	Success *TResult_ `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewAppendResult() *AppendResult {
	return &AppendResult{}
}

var AppendResult_Success_DEFAULT *TResult_

func (p *AppendResult) GetSuccess() *TResult_ {
	if !p.IsSetSuccess() {
		return AppendResult_Success_DEFAULT
	}
	return p.Success
}

var AppendResult_Io_DEFAULT *TIOError

func (p *AppendResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return AppendResult_Io_DEFAULT
	}
	return p.Io
}
func (p *AppendResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AppendResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *AppendResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AppendResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *AppendResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *AppendResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("append_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AppendResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *AppendResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *AppendResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AppendResult(%+v)", *p)
}

type OpenScannerArgs struct {
	Table []byte `thrift:"table,1,required" json:"table"`
	Tscan *TScan `thrift:"tscan,2,required" json:"tscan"`
}

func NewOpenScannerArgs() *OpenScannerArgs {
	return &OpenScannerArgs{}
}

func (p *OpenScannerArgs) GetTable() []byte {
	return p.Table
}

var OpenScannerArgs_Tscan_DEFAULT *TScan

func (p *OpenScannerArgs) GetTscan() *TScan {
	if !p.IsSetTscan() {
		return OpenScannerArgs_Tscan_DEFAULT
	}
	return p.Tscan
}
func (p *OpenScannerArgs) IsSetTscan() bool {
	return p.Tscan != nil
}

func (p *OpenScannerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenScannerArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *OpenScannerArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Tscan = &TScan{
		MaxVersions: 1,
	}
	if err := p.Tscan.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Tscan, err)
	}
	return nil
}

func (p *OpenScannerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("openScanner_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenScannerArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *OpenScannerArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tscan", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:tscan: %s", p, err)
	}
	if err := p.Tscan.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Tscan, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:tscan: %s", p, err)
	}
	return err
}

func (p *OpenScannerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenScannerArgs(%+v)", *p)
}

type OpenScannerResult struct {
	Success *int32    `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewOpenScannerResult() *OpenScannerResult {
	return &OpenScannerResult{}
}

var OpenScannerResult_Success_DEFAULT int32

func (p *OpenScannerResult) GetSuccess() int32 {
	if !p.IsSetSuccess() {
		return OpenScannerResult_Success_DEFAULT
	}
	return *p.Success
}

var OpenScannerResult_Io_DEFAULT *TIOError

func (p *OpenScannerResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return OpenScannerResult_Io_DEFAULT
	}
	return p.Io
}
func (p *OpenScannerResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *OpenScannerResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *OpenScannerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenScannerResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *OpenScannerResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *OpenScannerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("openScanner_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenScannerResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *OpenScannerResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *OpenScannerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenScannerResult(%+v)", *p)
}

type GetScannerRowsArgs struct {
	ScannerId int32 `thrift:"scannerId,1,required" json:"scannerId"`
	NumRows   int32 `thrift:"numRows,2" json:"numRows"`
}

func NewGetScannerRowsArgs() *GetScannerRowsArgs {
	return &GetScannerRowsArgs{
		NumRows: 1,
	}
}

func (p *GetScannerRowsArgs) GetScannerId() int32 {
	return p.ScannerId
}

func (p *GetScannerRowsArgs) GetNumRows() int32 {
	return p.NumRows
}
func (p *GetScannerRowsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetScannerRowsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ScannerId = v
	}
	return nil
}

func (p *GetScannerRowsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.NumRows = v
	}
	return nil
}

func (p *GetScannerRowsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getScannerRows_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetScannerRowsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scannerId", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scannerId: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ScannerId)); err != nil {
		return fmt.Errorf("%T.scannerId (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scannerId: %s", p, err)
	}
	return err
}

func (p *GetScannerRowsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("numRows", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:numRows: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.NumRows)); err != nil {
		return fmt.Errorf("%T.numRows (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:numRows: %s", p, err)
	}
	return err
}

func (p *GetScannerRowsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetScannerRowsArgs(%+v)", *p)
}

type GetScannerRowsResult struct {
	Success []*TResult_       `thrift:"success,0" json:"success"`
	Io      *TIOError         `thrift:"io,1" json:"io"`
	Ia      *TIllegalArgument `thrift:"ia,2" json:"ia"`
}

func NewGetScannerRowsResult() *GetScannerRowsResult {
	return &GetScannerRowsResult{}
}

var GetScannerRowsResult_Success_DEFAULT []*TResult_

func (p *GetScannerRowsResult) GetSuccess() []*TResult_ {
	return p.Success
}

var GetScannerRowsResult_Io_DEFAULT *TIOError

func (p *GetScannerRowsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return GetScannerRowsResult_Io_DEFAULT
	}
	return p.Io
}

var GetScannerRowsResult_Ia_DEFAULT *TIllegalArgument

func (p *GetScannerRowsResult) GetIa() *TIllegalArgument {
	if !p.IsSetIa() {
		return GetScannerRowsResult_Ia_DEFAULT
	}
	return p.Ia
}
func (p *GetScannerRowsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetScannerRowsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetScannerRowsResult) IsSetIa() bool {
	return p.Ia != nil
}

func (p *GetScannerRowsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetScannerRowsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem139 := &TResult_{}
		if err := _elem139.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem139, err)
		}
		p.Success = append(p.Success, _elem139)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetScannerRowsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetScannerRowsResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = &TIllegalArgument{}
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *GetScannerRowsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getScannerRows_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetScannerRowsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetScannerRowsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetScannerRowsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIa() {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *GetScannerRowsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetScannerRowsResult(%+v)", *p)
}

type CloseScannerArgs struct {
	ScannerId int32 `thrift:"scannerId,1,required" json:"scannerId"`
}

func NewCloseScannerArgs() *CloseScannerArgs {
	return &CloseScannerArgs{}
}

func (p *CloseScannerArgs) GetScannerId() int32 {
	return p.ScannerId
}
func (p *CloseScannerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseScannerArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ScannerId = v
	}
	return nil
}

func (p *CloseScannerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("closeScanner_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseScannerArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scannerId", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scannerId: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ScannerId)); err != nil {
		return fmt.Errorf("%T.scannerId (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scannerId: %s", p, err)
	}
	return err
}

func (p *CloseScannerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseScannerArgs(%+v)", *p)
}

type CloseScannerResult struct {
	Io *TIOError         `thrift:"io,1" json:"io"`
	Ia *TIllegalArgument `thrift:"ia,2" json:"ia"`
}

func NewCloseScannerResult() *CloseScannerResult {
	return &CloseScannerResult{}
}

var CloseScannerResult_Io_DEFAULT *TIOError

func (p *CloseScannerResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return CloseScannerResult_Io_DEFAULT
	}
	return p.Io
}

var CloseScannerResult_Ia_DEFAULT *TIllegalArgument

func (p *CloseScannerResult) GetIa() *TIllegalArgument {
	if !p.IsSetIa() {
		return CloseScannerResult_Ia_DEFAULT
	}
	return p.Ia
}
func (p *CloseScannerResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *CloseScannerResult) IsSetIa() bool {
	return p.Ia != nil
}

func (p *CloseScannerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseScannerResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *CloseScannerResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = &TIllegalArgument{}
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *CloseScannerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("closeScanner_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseScannerResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CloseScannerResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIa() {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *CloseScannerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseScannerResult(%+v)", *p)
}

type MutateRowArgs struct {
	Table         []byte         `thrift:"table,1,required" json:"table"`
	TrowMutations *TRowMutations `thrift:"trowMutations,2,required" json:"trowMutations"`
}

func NewMutateRowArgs() *MutateRowArgs {
	return &MutateRowArgs{}
}

func (p *MutateRowArgs) GetTable() []byte {
	return p.Table
}

var MutateRowArgs_TrowMutations_DEFAULT *TRowMutations

func (p *MutateRowArgs) GetTrowMutations() *TRowMutations {
	if !p.IsSetTrowMutations() {
		return MutateRowArgs_TrowMutations_DEFAULT
	}
	return p.TrowMutations
}
func (p *MutateRowArgs) IsSetTrowMutations() bool {
	return p.TrowMutations != nil
}

func (p *MutateRowArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *MutateRowArgs) ReadField2(iprot thrift.TProtocol) error {
	p.TrowMutations = &TRowMutations{}
	if err := p.TrowMutations.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.TrowMutations, err)
	}
	return nil
}

func (p *MutateRowArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRow_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *MutateRowArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("trowMutations", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:trowMutations: %s", p, err)
	}
	if err := p.TrowMutations.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.TrowMutations, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:trowMutations: %s", p, err)
	}
	return err
}

func (p *MutateRowArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowArgs(%+v)", *p)
}

type MutateRowResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewMutateRowResult() *MutateRowResult {
	return &MutateRowResult{}
}

var MutateRowResult_Io_DEFAULT *TIOError

func (p *MutateRowResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return MutateRowResult_Io_DEFAULT
	}
	return p.Io
}
func (p *MutateRowResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *MutateRowResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *MutateRowResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRow_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowResult(%+v)", *p)
}

type GetScannerResultsArgs struct {
	Table   []byte `thrift:"table,1,required" json:"table"`
	Tscan   *TScan `thrift:"tscan,2,required" json:"tscan"`
	NumRows int32  `thrift:"numRows,3" json:"numRows"`
}

func NewGetScannerResultsArgs() *GetScannerResultsArgs {
	return &GetScannerResultsArgs{
		NumRows: 1,
	}
}

func (p *GetScannerResultsArgs) GetTable() []byte {
	return p.Table
}

var GetScannerResultsArgs_Tscan_DEFAULT *TScan

func (p *GetScannerResultsArgs) GetTscan() *TScan {
	if !p.IsSetTscan() {
		return GetScannerResultsArgs_Tscan_DEFAULT
	}
	return p.Tscan
}

func (p *GetScannerResultsArgs) GetNumRows() int32 {
	return p.NumRows
}
func (p *GetScannerResultsArgs) IsSetTscan() bool {
	return p.Tscan != nil
}

func (p *GetScannerResultsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetScannerResultsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *GetScannerResultsArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Tscan = &TScan{
		MaxVersions: 1,
	}
	if err := p.Tscan.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Tscan, err)
	}
	return nil
}

func (p *GetScannerResultsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.NumRows = v
	}
	return nil
}

func (p *GetScannerResultsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getScannerResults_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetScannerResultsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *GetScannerResultsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tscan", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:tscan: %s", p, err)
	}
	if err := p.Tscan.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Tscan, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:tscan: %s", p, err)
	}
	return err
}

func (p *GetScannerResultsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("numRows", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:numRows: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.NumRows)); err != nil {
		return fmt.Errorf("%T.numRows (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:numRows: %s", p, err)
	}
	return err
}

func (p *GetScannerResultsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetScannerResultsArgs(%+v)", *p)
}

type GetScannerResultsResult struct {
	Success []*TResult_ `thrift:"success,0" json:"success"`
	Io      *TIOError   `thrift:"io,1" json:"io"`
}

func NewGetScannerResultsResult() *GetScannerResultsResult {
	return &GetScannerResultsResult{}
}

var GetScannerResultsResult_Success_DEFAULT []*TResult_

func (p *GetScannerResultsResult) GetSuccess() []*TResult_ {
	return p.Success
}

var GetScannerResultsResult_Io_DEFAULT *TIOError

func (p *GetScannerResultsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return GetScannerResultsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetScannerResultsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetScannerResultsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetScannerResultsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetScannerResultsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem140 := &TResult_{}
		if err := _elem140.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem140, err)
		}
		p.Success = append(p.Success, _elem140)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetScannerResultsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetScannerResultsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getScannerResults_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetScannerResultsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetScannerResultsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetScannerResultsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetScannerResultsResult(%+v)", *p)
}

type GetRegionLocationArgs struct {
	Table  []byte `thrift:"table,1,required" json:"table"`
	Row    []byte `thrift:"row,2,required" json:"row"`
	Reload bool   `thrift:"reload,3" json:"reload"`
}

func NewGetRegionLocationArgs() *GetRegionLocationArgs {
	return &GetRegionLocationArgs{}
}

func (p *GetRegionLocationArgs) GetTable() []byte {
	return p.Table
}

func (p *GetRegionLocationArgs) GetRow() []byte {
	return p.Row
}

func (p *GetRegionLocationArgs) GetReload() bool {
	return p.Reload
}
func (p *GetRegionLocationArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRegionLocationArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *GetRegionLocationArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *GetRegionLocationArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Reload = v
	}
	return nil
}

func (p *GetRegionLocationArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRegionLocation_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRegionLocationArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *GetRegionLocationArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *GetRegionLocationArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("reload", thrift.BOOL, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:reload: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Reload)); err != nil {
		return fmt.Errorf("%T.reload (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:reload: %s", p, err)
	}
	return err
}

func (p *GetRegionLocationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRegionLocationArgs(%+v)", *p)
}

type GetRegionLocationResult struct {
	Success *THRegionLocation `thrift:"success,0" json:"success"`
	Io      *TIOError         `thrift:"io,1" json:"io"`
}

func NewGetRegionLocationResult() *GetRegionLocationResult {
	return &GetRegionLocationResult{}
}

var GetRegionLocationResult_Success_DEFAULT *THRegionLocation

func (p *GetRegionLocationResult) GetSuccess() *THRegionLocation {
	if !p.IsSetSuccess() {
		return GetRegionLocationResult_Success_DEFAULT
	}
	return p.Success
}

var GetRegionLocationResult_Io_DEFAULT *TIOError

func (p *GetRegionLocationResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return GetRegionLocationResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetRegionLocationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetRegionLocationResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetRegionLocationResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRegionLocationResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &THRegionLocation{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetRegionLocationResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRegionLocationResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRegionLocation_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRegionLocationResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRegionLocationResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRegionLocationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRegionLocationResult(%+v)", *p)
}

type GetAllRegionLocationsArgs struct {
	Table []byte `thrift:"table,1,required" json:"table"`
}

func NewGetAllRegionLocationsArgs() *GetAllRegionLocationsArgs {
	return &GetAllRegionLocationsArgs{}
}

func (p *GetAllRegionLocationsArgs) GetTable() []byte {
	return p.Table
}
func (p *GetAllRegionLocationsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetAllRegionLocationsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *GetAllRegionLocationsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getAllRegionLocations_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetAllRegionLocationsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *GetAllRegionLocationsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetAllRegionLocationsArgs(%+v)", *p)
}

type GetAllRegionLocationsResult struct {
	Success []*THRegionLocation `thrift:"success,0" json:"success"`
	Io      *TIOError           `thrift:"io,1" json:"io"`
}

func NewGetAllRegionLocationsResult() *GetAllRegionLocationsResult {
	return &GetAllRegionLocationsResult{}
}

var GetAllRegionLocationsResult_Success_DEFAULT []*THRegionLocation

func (p *GetAllRegionLocationsResult) GetSuccess() []*THRegionLocation {
	return p.Success
}

var GetAllRegionLocationsResult_Io_DEFAULT *TIOError

func (p *GetAllRegionLocationsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return GetAllRegionLocationsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetAllRegionLocationsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetAllRegionLocationsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetAllRegionLocationsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetAllRegionLocationsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*THRegionLocation, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem141 := &THRegionLocation{}
		if err := _elem141.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem141, err)
		}
		p.Success = append(p.Success, _elem141)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetAllRegionLocationsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetAllRegionLocationsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getAllRegionLocations_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetAllRegionLocationsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetAllRegionLocationsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetAllRegionLocationsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetAllRegionLocationsResult(%+v)", *p)
}

type CheckAndMutateArgs struct {
	Table        []byte         `thrift:"table,1,required" json:"table"`
	Row          []byte         `thrift:"row,2,required" json:"row"`
	Family       []byte         `thrift:"family,3,required" json:"family"`
	Qualifier    []byte         `thrift:"qualifier,4,required" json:"qualifier"`
	CompareOp    TCompareOp     `thrift:"compareOp,5,required" json:"compareOp"`
	Value        []byte         `thrift:"value,6" json:"value"`
	RowMutations *TRowMutations `thrift:"rowMutations,7,required" json:"rowMutations"`
}

func NewCheckAndMutateArgs() *CheckAndMutateArgs {
	return &CheckAndMutateArgs{}
}

func (p *CheckAndMutateArgs) GetTable() []byte {
	return p.Table
}

func (p *CheckAndMutateArgs) GetRow() []byte {
	return p.Row
}

func (p *CheckAndMutateArgs) GetFamily() []byte {
	return p.Family
}

func (p *CheckAndMutateArgs) GetQualifier() []byte {
	return p.Qualifier
}

func (p *CheckAndMutateArgs) GetCompareOp() TCompareOp {
	return p.CompareOp
}

func (p *CheckAndMutateArgs) GetValue() []byte {
	return p.Value
}

var CheckAndMutateArgs_RowMutations_DEFAULT *TRowMutations

func (p *CheckAndMutateArgs) GetRowMutations() *TRowMutations {
	if !p.IsSetRowMutations() {
		return CheckAndMutateArgs_RowMutations_DEFAULT
	}
	return p.RowMutations
}
func (p *CheckAndMutateArgs) IsSetRowMutations() bool {
	return p.RowMutations != nil
}

func (p *CheckAndMutateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		case 7:
			if err := p.ReadField7(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckAndMutateArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *CheckAndMutateArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *CheckAndMutateArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Family = v
	}
	return nil
}

func (p *CheckAndMutateArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Qualifier = v
	}
	return nil
}

func (p *CheckAndMutateArgs) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		temp := TCompareOp(v)
		p.CompareOp = temp
	}
	return nil
}

func (p *CheckAndMutateArgs) ReadField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 6: %s", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *CheckAndMutateArgs) ReadField7(iprot thrift.TProtocol) error {
	p.RowMutations = &TRowMutations{}
	if err := p.RowMutations.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.RowMutations, err)
	}
	return nil
}

func (p *CheckAndMutateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndMutate_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := p.writeField7(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckAndMutateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *CheckAndMutateArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *CheckAndMutateArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("family", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:family: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Family); err != nil {
		return fmt.Errorf("%T.family (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:family: %s", p, err)
	}
	return err
}

func (p *CheckAndMutateArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("qualifier", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:qualifier: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Qualifier); err != nil {
		return fmt.Errorf("%T.qualifier (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:qualifier: %s", p, err)
	}
	return err
}

func (p *CheckAndMutateArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("compareOp", thrift.I32, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:compareOp: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.CompareOp)); err != nil {
		return fmt.Errorf("%T.compareOp (5) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:compareOp: %s", p, err)
	}
	return err
}

func (p *CheckAndMutateArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.STRING, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:value: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Value); err != nil {
		return fmt.Errorf("%T.value (6) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 6:value: %s", p, err)
	}
	return err
}

func (p *CheckAndMutateArgs) writeField7(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("rowMutations", thrift.STRUCT, 7); err != nil {
		return fmt.Errorf("%T write field begin error 7:rowMutations: %s", p, err)
	}
	if err := p.RowMutations.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.RowMutations, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 7:rowMutations: %s", p, err)
	}
	return err
}

func (p *CheckAndMutateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckAndMutateArgs(%+v)", *p)
}

type CheckAndMutateResult struct {
	Success *bool     `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewCheckAndMutateResult() *CheckAndMutateResult {
	return &CheckAndMutateResult{}
}

var CheckAndMutateResult_Success_DEFAULT bool

func (p *CheckAndMutateResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return CheckAndMutateResult_Success_DEFAULT
	}
	return *p.Success
}

var CheckAndMutateResult_Io_DEFAULT *TIOError

func (p *CheckAndMutateResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return CheckAndMutateResult_Io_DEFAULT
	}
	return p.Io
}
func (p *CheckAndMutateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CheckAndMutateResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *CheckAndMutateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckAndMutateResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CheckAndMutateResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *CheckAndMutateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndMutate_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckAndMutateResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndMutateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndMutateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckAndMutateResult(%+v)", *p)
}

type GetTableDescriptorArgs struct {
	Table *TTableName `thrift:"table,1,required" json:"table"`
}

func NewGetTableDescriptorArgs() *GetTableDescriptorArgs {
	return &GetTableDescriptorArgs{}
}

var GetTableDescriptorArgs_Table_DEFAULT *TTableName

func (p *GetTableDescriptorArgs) GetTable() *TTableName {
	if !p.IsSetTable() {
		return GetTableDescriptorArgs_Table_DEFAULT
	}
	return p.Table
}
func (p *GetTableDescriptorArgs) IsSetTable() bool {
	return p.Table != nil
}

func (p *GetTableDescriptorArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableDescriptorArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Table = &TTableName{}
	if err := p.Table.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Table, err)
	}
	return nil
}

func (p *GetTableDescriptorArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableDescriptor_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableDescriptorArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := p.Table.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Table, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *GetTableDescriptorArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableDescriptorArgs(%+v)", *p)
}

type GetTableDescriptorResult struct {
	Success *TTableDescriptor `thrift:"success,0" json:"success"`
	Io      *TIOError         `thrift:"io,1" json:"io"`
}

func NewGetTableDescriptorResult() *GetTableDescriptorResult {
	return &GetTableDescriptorResult{}
}

var GetTableDescriptorResult_Success_DEFAULT *TTableDescriptor

func (p *GetTableDescriptorResult) GetSuccess() *TTableDescriptor {
	if !p.IsSetSuccess() {
		return GetTableDescriptorResult_Success_DEFAULT
	}
	return p.Success
}

var GetTableDescriptorResult_Io_DEFAULT *TIOError

func (p *GetTableDescriptorResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return GetTableDescriptorResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetTableDescriptorResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTableDescriptorResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetTableDescriptorResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableDescriptorResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TTableDescriptor{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetTableDescriptorResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetTableDescriptorResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableDescriptor_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableDescriptorResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTableDescriptorResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetTableDescriptorResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableDescriptorResult(%+v)", *p)
}

type GetTableDescriptorsArgs struct {
	Tables []*TTableName `thrift:"tables,1,required" json:"tables"`
}

func NewGetTableDescriptorsArgs() *GetTableDescriptorsArgs {
	return &GetTableDescriptorsArgs{}
}

func (p *GetTableDescriptorsArgs) GetTables() []*TTableName {
	return p.Tables
}
func (p *GetTableDescriptorsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableDescriptorsArgs) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TTableName, 0, size)
	p.Tables = tSlice
	for i := 0; i < size; i++ {
		_elem142 := &TTableName{}
		if err := _elem142.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem142, err)
		}
		p.Tables = append(p.Tables, _elem142)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTableDescriptorsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableDescriptors_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableDescriptorsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tables", thrift.LIST, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tables: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Tables)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Tables {
		if err := v.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", v, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tables: %s", p, err)
	}
	return err
}

func (p *GetTableDescriptorsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableDescriptorsArgs(%+v)", *p)
}

type GetTableDescriptorsResult struct {
	Success []*TTableDescriptor `thrift:"success,0" json:"success"`
	Io      *TIOError           `thrift:"io,1" json:"io"`
}

func NewGetTableDescriptorsResult() *GetTableDescriptorsResult {
	return &GetTableDescriptorsResult{}
}

var GetTableDescriptorsResult_Success_DEFAULT []*TTableDescriptor

func (p *GetTableDescriptorsResult) GetSuccess() []*TTableDescriptor {
	return p.Success
}

var GetTableDescriptorsResult_Io_DEFAULT *TIOError

func (p *GetTableDescriptorsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return GetTableDescriptorsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetTableDescriptorsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTableDescriptorsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetTableDescriptorsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableDescriptorsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TTableDescriptor, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem143 := &TTableDescriptor{}
		if err := _elem143.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem143, err)
		}
		p.Success = append(p.Success, _elem143)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTableDescriptorsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetTableDescriptorsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableDescriptors_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableDescriptorsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTableDescriptorsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetTableDescriptorsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableDescriptorsResult(%+v)", *p)
}

type TableExistsArgs struct {
	TableName *TTableName `thrift:"tableName,1" json:"tableName"`
}

func NewTableExistsArgs() *TableExistsArgs {
	return &TableExistsArgs{}
}

var TableExistsArgs_TableName_DEFAULT *TTableName

func (p *TableExistsArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return TableExistsArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *TableExistsArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *TableExistsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableExistsArgs) ReadField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.TableName, err)
	}
	return nil
}

func (p *TableExistsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("tableExists_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TableExistsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.TableName, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *TableExistsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableExistsArgs(%+v)", *p)
}

type TableExistsResult struct {
	Success *bool     `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewTableExistsResult() *TableExistsResult {
	return &TableExistsResult{}
}

var TableExistsResult_Success_DEFAULT bool

func (p *TableExistsResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return TableExistsResult_Success_DEFAULT
	}
	return *p.Success
}

var TableExistsResult_Io_DEFAULT *TIOError

func (p *TableExistsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return TableExistsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *TableExistsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TableExistsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *TableExistsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TableExistsResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *TableExistsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *TableExistsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("tableExists_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TableExistsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TableExistsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *TableExistsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TableExistsResult(%+v)", *p)
}

type GetTableDescriptorsByPatternArgs struct {
	Regex            string `thrift:"regex,1" json:"regex"`
	IncludeSysTables bool   `thrift:"includeSysTables,2,required" json:"includeSysTables"`
}

func NewGetTableDescriptorsByPatternArgs() *GetTableDescriptorsByPatternArgs {
	return &GetTableDescriptorsByPatternArgs{}
}

func (p *GetTableDescriptorsByPatternArgs) GetRegex() string {
	return p.Regex
}

func (p *GetTableDescriptorsByPatternArgs) GetIncludeSysTables() bool {
	return p.IncludeSysTables
}
func (p *GetTableDescriptorsByPatternArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableDescriptorsByPatternArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Regex = v
	}
	return nil
}

func (p *GetTableDescriptorsByPatternArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.IncludeSysTables = v
	}
	return nil
}

func (p *GetTableDescriptorsByPatternArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableDescriptorsByPattern_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableDescriptorsByPatternArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("regex", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:regex: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Regex)); err != nil {
		return fmt.Errorf("%T.regex (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:regex: %s", p, err)
	}
	return err
}

func (p *GetTableDescriptorsByPatternArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("includeSysTables", thrift.BOOL, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:includeSysTables: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.IncludeSysTables)); err != nil {
		return fmt.Errorf("%T.includeSysTables (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:includeSysTables: %s", p, err)
	}
	return err
}

func (p *GetTableDescriptorsByPatternArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableDescriptorsByPatternArgs(%+v)", *p)
}

type GetTableDescriptorsByPatternResult struct {
	Success []*TTableDescriptor `thrift:"success,0" json:"success"`
	Io      *TIOError           `thrift:"io,1" json:"io"`
}

func NewGetTableDescriptorsByPatternResult() *GetTableDescriptorsByPatternResult {
	return &GetTableDescriptorsByPatternResult{}
}

var GetTableDescriptorsByPatternResult_Success_DEFAULT []*TTableDescriptor

func (p *GetTableDescriptorsByPatternResult) GetSuccess() []*TTableDescriptor {
	return p.Success
}

var GetTableDescriptorsByPatternResult_Io_DEFAULT *TIOError

func (p *GetTableDescriptorsByPatternResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return GetTableDescriptorsByPatternResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetTableDescriptorsByPatternResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTableDescriptorsByPatternResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetTableDescriptorsByPatternResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableDescriptorsByPatternResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TTableDescriptor, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem144 := &TTableDescriptor{}
		if err := _elem144.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem144, err)
		}
		p.Success = append(p.Success, _elem144)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTableDescriptorsByPatternResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetTableDescriptorsByPatternResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableDescriptorsByPattern_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableDescriptorsByPatternResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTableDescriptorsByPatternResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetTableDescriptorsByPatternResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableDescriptorsByPatternResult(%+v)", *p)
}

type GetTableDescriptorsByNamespaceArgs struct {
	Name string `thrift:"name,1,required" json:"name"`
}

func NewGetTableDescriptorsByNamespaceArgs() *GetTableDescriptorsByNamespaceArgs {
	return &GetTableDescriptorsByNamespaceArgs{}
}

func (p *GetTableDescriptorsByNamespaceArgs) GetName() string {
	return p.Name
}
func (p *GetTableDescriptorsByNamespaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableDescriptorsByNamespaceArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *GetTableDescriptorsByNamespaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableDescriptorsByNamespace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableDescriptorsByNamespaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *GetTableDescriptorsByNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableDescriptorsByNamespaceArgs(%+v)", *p)
}

type GetTableDescriptorsByNamespaceResult struct {
	Success []*TTableDescriptor `thrift:"success,0" json:"success"`
	Io      *TIOError           `thrift:"io,1" json:"io"`
}

func NewGetTableDescriptorsByNamespaceResult() *GetTableDescriptorsByNamespaceResult {
	return &GetTableDescriptorsByNamespaceResult{}
}

var GetTableDescriptorsByNamespaceResult_Success_DEFAULT []*TTableDescriptor

func (p *GetTableDescriptorsByNamespaceResult) GetSuccess() []*TTableDescriptor {
	return p.Success
}

var GetTableDescriptorsByNamespaceResult_Io_DEFAULT *TIOError

func (p *GetTableDescriptorsByNamespaceResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return GetTableDescriptorsByNamespaceResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetTableDescriptorsByNamespaceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTableDescriptorsByNamespaceResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetTableDescriptorsByNamespaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableDescriptorsByNamespaceResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TTableDescriptor, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem145 := &TTableDescriptor{}
		if err := _elem145.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem145, err)
		}
		p.Success = append(p.Success, _elem145)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTableDescriptorsByNamespaceResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetTableDescriptorsByNamespaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableDescriptorsByNamespace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableDescriptorsByNamespaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTableDescriptorsByNamespaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetTableDescriptorsByNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableDescriptorsByNamespaceResult(%+v)", *p)
}

type GetTableNamesByPatternArgs struct {
	Regex            string `thrift:"regex,1" json:"regex"`
	IncludeSysTables bool   `thrift:"includeSysTables,2,required" json:"includeSysTables"`
}

func NewGetTableNamesByPatternArgs() *GetTableNamesByPatternArgs {
	return &GetTableNamesByPatternArgs{}
}

func (p *GetTableNamesByPatternArgs) GetRegex() string {
	return p.Regex
}

func (p *GetTableNamesByPatternArgs) GetIncludeSysTables() bool {
	return p.IncludeSysTables
}
func (p *GetTableNamesByPatternArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableNamesByPatternArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Regex = v
	}
	return nil
}

func (p *GetTableNamesByPatternArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.IncludeSysTables = v
	}
	return nil
}

func (p *GetTableNamesByPatternArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableNamesByPattern_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableNamesByPatternArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("regex", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:regex: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Regex)); err != nil {
		return fmt.Errorf("%T.regex (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:regex: %s", p, err)
	}
	return err
}

func (p *GetTableNamesByPatternArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("includeSysTables", thrift.BOOL, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:includeSysTables: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.IncludeSysTables)); err != nil {
		return fmt.Errorf("%T.includeSysTables (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:includeSysTables: %s", p, err)
	}
	return err
}

func (p *GetTableNamesByPatternArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableNamesByPatternArgs(%+v)", *p)
}

type GetTableNamesByPatternResult struct {
	Success []*TTableName `thrift:"success,0" json:"success"`
	Io      *TIOError     `thrift:"io,1" json:"io"`
}

func NewGetTableNamesByPatternResult() *GetTableNamesByPatternResult {
	return &GetTableNamesByPatternResult{}
}

var GetTableNamesByPatternResult_Success_DEFAULT []*TTableName

func (p *GetTableNamesByPatternResult) GetSuccess() []*TTableName {
	return p.Success
}

var GetTableNamesByPatternResult_Io_DEFAULT *TIOError

func (p *GetTableNamesByPatternResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return GetTableNamesByPatternResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetTableNamesByPatternResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTableNamesByPatternResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetTableNamesByPatternResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableNamesByPatternResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TTableName, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem146 := &TTableName{}
		if err := _elem146.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem146, err)
		}
		p.Success = append(p.Success, _elem146)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTableNamesByPatternResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetTableNamesByPatternResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableNamesByPattern_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableNamesByPatternResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTableNamesByPatternResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetTableNamesByPatternResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableNamesByPatternResult(%+v)", *p)
}

type GetTableNamesByNamespaceArgs struct {
	Name string `thrift:"name,1,required" json:"name"`
}

func NewGetTableNamesByNamespaceArgs() *GetTableNamesByNamespaceArgs {
	return &GetTableNamesByNamespaceArgs{}
}

func (p *GetTableNamesByNamespaceArgs) GetName() string {
	return p.Name
}
func (p *GetTableNamesByNamespaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableNamesByNamespaceArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *GetTableNamesByNamespaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableNamesByNamespace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableNamesByNamespaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *GetTableNamesByNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableNamesByNamespaceArgs(%+v)", *p)
}

type GetTableNamesByNamespaceResult struct {
	Success []*TTableName `thrift:"success,0" json:"success"`
	Io      *TIOError     `thrift:"io,1" json:"io"`
}

func NewGetTableNamesByNamespaceResult() *GetTableNamesByNamespaceResult {
	return &GetTableNamesByNamespaceResult{}
}

var GetTableNamesByNamespaceResult_Success_DEFAULT []*TTableName

func (p *GetTableNamesByNamespaceResult) GetSuccess() []*TTableName {
	return p.Success
}

var GetTableNamesByNamespaceResult_Io_DEFAULT *TIOError

func (p *GetTableNamesByNamespaceResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return GetTableNamesByNamespaceResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetTableNamesByNamespaceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTableNamesByNamespaceResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetTableNamesByNamespaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableNamesByNamespaceResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TTableName, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem147 := &TTableName{}
		if err := _elem147.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem147, err)
		}
		p.Success = append(p.Success, _elem147)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTableNamesByNamespaceResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetTableNamesByNamespaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableNamesByNamespace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableNamesByNamespaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTableNamesByNamespaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetTableNamesByNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableNamesByNamespaceResult(%+v)", *p)
}

type CreateTableArgs struct {
	Desc      *TTableDescriptor `thrift:"desc,1,required" json:"desc"`
	SplitKeys [][]byte          `thrift:"splitKeys,2" json:"splitKeys"`
}

func NewCreateTableArgs() *CreateTableArgs {
	return &CreateTableArgs{}
}

var CreateTableArgs_Desc_DEFAULT *TTableDescriptor

func (p *CreateTableArgs) GetDesc() *TTableDescriptor {
	if !p.IsSetDesc() {
		return CreateTableArgs_Desc_DEFAULT
	}
	return p.Desc
}

func (p *CreateTableArgs) GetSplitKeys() [][]byte {
	return p.SplitKeys
}
func (p *CreateTableArgs) IsSetDesc() bool {
	return p.Desc != nil
}

func (p *CreateTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateTableArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Desc = &TTableDescriptor{}
	if err := p.Desc.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Desc, err)
	}
	return nil
}

func (p *CreateTableArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.SplitKeys = tSlice
	for i := 0; i < size; i++ {
		var _elem148 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem148 = v
		}
		p.SplitKeys = append(p.SplitKeys, _elem148)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *CreateTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("desc", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:desc: %s", p, err)
	}
	if err := p.Desc.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Desc, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:desc: %s", p, err)
	}
	return err
}

func (p *CreateTableArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("splitKeys", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:splitKeys: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.SplitKeys)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.SplitKeys {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:splitKeys: %s", p, err)
	}
	return err
}

func (p *CreateTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateTableArgs(%+v)", *p)
}

type CreateTableResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewCreateTableResult() *CreateTableResult {
	return &CreateTableResult{}
}

var CreateTableResult_Io_DEFAULT *TIOError

func (p *CreateTableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return CreateTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *CreateTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *CreateTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateTableResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *CreateTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CreateTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateTableResult(%+v)", *p)
}

type DeleteTableArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" json:"tableName"`
}

func NewDeleteTableArgs() *DeleteTableArgs {
	return &DeleteTableArgs{}
}

var DeleteTableArgs_TableName_DEFAULT *TTableName

func (p *DeleteTableArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return DeleteTableArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *DeleteTableArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *DeleteTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteTableArgs) ReadField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.TableName, err)
	}
	return nil
}

func (p *DeleteTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.TableName, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *DeleteTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteTableArgs(%+v)", *p)
}

type DeleteTableResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewDeleteTableResult() *DeleteTableResult {
	return &DeleteTableResult{}
}

var DeleteTableResult_Io_DEFAULT *TIOError

func (p *DeleteTableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return DeleteTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *DeleteTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *DeleteTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteTableResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteTableResult(%+v)", *p)
}

type TruncateTableArgs struct {
	TableName      *TTableName `thrift:"tableName,1,required" json:"tableName"`
	PreserveSplits bool        `thrift:"preserveSplits,2,required" json:"preserveSplits"`
}

func NewTruncateTableArgs() *TruncateTableArgs {
	return &TruncateTableArgs{}
}

var TruncateTableArgs_TableName_DEFAULT *TTableName

func (p *TruncateTableArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return TruncateTableArgs_TableName_DEFAULT
	}
	return p.TableName
}

func (p *TruncateTableArgs) GetPreserveSplits() bool {
	return p.PreserveSplits
}
func (p *TruncateTableArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *TruncateTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TruncateTableArgs) ReadField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.TableName, err)
	}
	return nil
}

func (p *TruncateTableArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.PreserveSplits = v
	}
	return nil
}

func (p *TruncateTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("truncateTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TruncateTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.TableName, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *TruncateTableArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("preserveSplits", thrift.BOOL, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:preserveSplits: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.PreserveSplits)); err != nil {
		return fmt.Errorf("%T.preserveSplits (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:preserveSplits: %s", p, err)
	}
	return err
}

func (p *TruncateTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TruncateTableArgs(%+v)", *p)
}

type TruncateTableResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewTruncateTableResult() *TruncateTableResult {
	return &TruncateTableResult{}
}

var TruncateTableResult_Io_DEFAULT *TIOError

func (p *TruncateTableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return TruncateTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *TruncateTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *TruncateTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TruncateTableResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *TruncateTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("truncateTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TruncateTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *TruncateTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TruncateTableResult(%+v)", *p)
}

type EnableTableArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" json:"tableName"`
}

func NewEnableTableArgs() *EnableTableArgs {
	return &EnableTableArgs{}
}

var EnableTableArgs_TableName_DEFAULT *TTableName

func (p *EnableTableArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return EnableTableArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *EnableTableArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *EnableTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EnableTableArgs) ReadField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.TableName, err)
	}
	return nil
}

func (p *EnableTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("enableTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *EnableTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.TableName, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *EnableTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EnableTableArgs(%+v)", *p)
}

type EnableTableResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewEnableTableResult() *EnableTableResult {
	return &EnableTableResult{}
}

var EnableTableResult_Io_DEFAULT *TIOError

func (p *EnableTableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return EnableTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *EnableTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *EnableTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EnableTableResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *EnableTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("enableTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *EnableTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *EnableTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EnableTableResult(%+v)", *p)
}

type DisableTableArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" json:"tableName"`
}

func NewDisableTableArgs() *DisableTableArgs {
	return &DisableTableArgs{}
}

var DisableTableArgs_TableName_DEFAULT *TTableName

func (p *DisableTableArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return DisableTableArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *DisableTableArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *DisableTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DisableTableArgs) ReadField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.TableName, err)
	}
	return nil
}

func (p *DisableTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("disableTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DisableTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.TableName, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *DisableTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DisableTableArgs(%+v)", *p)
}

type DisableTableResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewDisableTableResult() *DisableTableResult {
	return &DisableTableResult{}
}

var DisableTableResult_Io_DEFAULT *TIOError

func (p *DisableTableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return DisableTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *DisableTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *DisableTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DisableTableResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DisableTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("disableTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DisableTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DisableTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DisableTableResult(%+v)", *p)
}

type IsTableEnabledArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" json:"tableName"`
}

func NewIsTableEnabledArgs() *IsTableEnabledArgs {
	return &IsTableEnabledArgs{}
}

var IsTableEnabledArgs_TableName_DEFAULT *TTableName

func (p *IsTableEnabledArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return IsTableEnabledArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *IsTableEnabledArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *IsTableEnabledArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IsTableEnabledArgs) ReadField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.TableName, err)
	}
	return nil
}

func (p *IsTableEnabledArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableEnabled_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IsTableEnabledArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.TableName, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *IsTableEnabledArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IsTableEnabledArgs(%+v)", *p)
}

type IsTableEnabledResult struct {
	Success *bool     `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewIsTableEnabledResult() *IsTableEnabledResult {
	return &IsTableEnabledResult{}
}

var IsTableEnabledResult_Success_DEFAULT bool

func (p *IsTableEnabledResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return IsTableEnabledResult_Success_DEFAULT
	}
	return *p.Success
}

var IsTableEnabledResult_Io_DEFAULT *TIOError

func (p *IsTableEnabledResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return IsTableEnabledResult_Io_DEFAULT
	}
	return p.Io
}
func (p *IsTableEnabledResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *IsTableEnabledResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *IsTableEnabledResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IsTableEnabledResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *IsTableEnabledResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *IsTableEnabledResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableEnabled_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IsTableEnabledResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *IsTableEnabledResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *IsTableEnabledResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IsTableEnabledResult(%+v)", *p)
}

type IsTableDisabledArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" json:"tableName"`
}

func NewIsTableDisabledArgs() *IsTableDisabledArgs {
	return &IsTableDisabledArgs{}
}

var IsTableDisabledArgs_TableName_DEFAULT *TTableName

func (p *IsTableDisabledArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return IsTableDisabledArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *IsTableDisabledArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *IsTableDisabledArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IsTableDisabledArgs) ReadField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.TableName, err)
	}
	return nil
}

func (p *IsTableDisabledArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableDisabled_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IsTableDisabledArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.TableName, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *IsTableDisabledArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IsTableDisabledArgs(%+v)", *p)
}

type IsTableDisabledResult struct {
	Success *bool     `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewIsTableDisabledResult() *IsTableDisabledResult {
	return &IsTableDisabledResult{}
}

var IsTableDisabledResult_Success_DEFAULT bool

func (p *IsTableDisabledResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return IsTableDisabledResult_Success_DEFAULT
	}
	return *p.Success
}

var IsTableDisabledResult_Io_DEFAULT *TIOError

func (p *IsTableDisabledResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return IsTableDisabledResult_Io_DEFAULT
	}
	return p.Io
}
func (p *IsTableDisabledResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *IsTableDisabledResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *IsTableDisabledResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IsTableDisabledResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *IsTableDisabledResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *IsTableDisabledResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableDisabled_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IsTableDisabledResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *IsTableDisabledResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *IsTableDisabledResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IsTableDisabledResult(%+v)", *p)
}

type IsTableAvailableArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" json:"tableName"`
}

func NewIsTableAvailableArgs() *IsTableAvailableArgs {
	return &IsTableAvailableArgs{}
}

var IsTableAvailableArgs_TableName_DEFAULT *TTableName

func (p *IsTableAvailableArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return IsTableAvailableArgs_TableName_DEFAULT
	}
	return p.TableName
}
func (p *IsTableAvailableArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *IsTableAvailableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IsTableAvailableArgs) ReadField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.TableName, err)
	}
	return nil
}

func (p *IsTableAvailableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableAvailable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IsTableAvailableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.TableName, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *IsTableAvailableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IsTableAvailableArgs(%+v)", *p)
}

type IsTableAvailableResult struct {
	Success *bool     `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewIsTableAvailableResult() *IsTableAvailableResult {
	return &IsTableAvailableResult{}
}

var IsTableAvailableResult_Success_DEFAULT bool

func (p *IsTableAvailableResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return IsTableAvailableResult_Success_DEFAULT
	}
	return *p.Success
}

var IsTableAvailableResult_Io_DEFAULT *TIOError

func (p *IsTableAvailableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return IsTableAvailableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *IsTableAvailableResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *IsTableAvailableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *IsTableAvailableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IsTableAvailableResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *IsTableAvailableResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *IsTableAvailableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableAvailable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IsTableAvailableResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *IsTableAvailableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *IsTableAvailableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IsTableAvailableResult(%+v)", *p)
}

type IsTableAvailableWithSplitArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" json:"tableName"`
	SplitKeys [][]byte    `thrift:"splitKeys,2" json:"splitKeys"`
}

func NewIsTableAvailableWithSplitArgs() *IsTableAvailableWithSplitArgs {
	return &IsTableAvailableWithSplitArgs{}
}

var IsTableAvailableWithSplitArgs_TableName_DEFAULT *TTableName

func (p *IsTableAvailableWithSplitArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return IsTableAvailableWithSplitArgs_TableName_DEFAULT
	}
	return p.TableName
}

func (p *IsTableAvailableWithSplitArgs) GetSplitKeys() [][]byte {
	return p.SplitKeys
}
func (p *IsTableAvailableWithSplitArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *IsTableAvailableWithSplitArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IsTableAvailableWithSplitArgs) ReadField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.TableName, err)
	}
	return nil
}

func (p *IsTableAvailableWithSplitArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.SplitKeys = tSlice
	for i := 0; i < size; i++ {
		var _elem149 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem149 = v
		}
		p.SplitKeys = append(p.SplitKeys, _elem149)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *IsTableAvailableWithSplitArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableAvailableWithSplit_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IsTableAvailableWithSplitArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.TableName, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *IsTableAvailableWithSplitArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("splitKeys", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:splitKeys: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.SplitKeys)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.SplitKeys {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:splitKeys: %s", p, err)
	}
	return err
}

func (p *IsTableAvailableWithSplitArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IsTableAvailableWithSplitArgs(%+v)", *p)
}

type IsTableAvailableWithSplitResult struct {
	Success *bool     `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewIsTableAvailableWithSplitResult() *IsTableAvailableWithSplitResult {
	return &IsTableAvailableWithSplitResult{}
}

var IsTableAvailableWithSplitResult_Success_DEFAULT bool

func (p *IsTableAvailableWithSplitResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return IsTableAvailableWithSplitResult_Success_DEFAULT
	}
	return *p.Success
}

var IsTableAvailableWithSplitResult_Io_DEFAULT *TIOError

func (p *IsTableAvailableWithSplitResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return IsTableAvailableWithSplitResult_Io_DEFAULT
	}
	return p.Io
}
func (p *IsTableAvailableWithSplitResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *IsTableAvailableWithSplitResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *IsTableAvailableWithSplitResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IsTableAvailableWithSplitResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *IsTableAvailableWithSplitResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *IsTableAvailableWithSplitResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableAvailableWithSplit_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IsTableAvailableWithSplitResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *IsTableAvailableWithSplitResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *IsTableAvailableWithSplitResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IsTableAvailableWithSplitResult(%+v)", *p)
}

type AddColumnFamilyArgs struct {
	TableName *TTableName              `thrift:"tableName,1,required" json:"tableName"`
	Column    *TColumnFamilyDescriptor `thrift:"column,2,required" json:"column"`
}

func NewAddColumnFamilyArgs() *AddColumnFamilyArgs {
	return &AddColumnFamilyArgs{}
}

var AddColumnFamilyArgs_TableName_DEFAULT *TTableName

func (p *AddColumnFamilyArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return AddColumnFamilyArgs_TableName_DEFAULT
	}
	return p.TableName
}

var AddColumnFamilyArgs_Column_DEFAULT *TColumnFamilyDescriptor

func (p *AddColumnFamilyArgs) GetColumn() *TColumnFamilyDescriptor {
	if !p.IsSetColumn() {
		return AddColumnFamilyArgs_Column_DEFAULT
	}
	return p.Column
}
func (p *AddColumnFamilyArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *AddColumnFamilyArgs) IsSetColumn() bool {
	return p.Column != nil
}

func (p *AddColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AddColumnFamilyArgs) ReadField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.TableName, err)
	}
	return nil
}

func (p *AddColumnFamilyArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Column = &TColumnFamilyDescriptor{}
	if err := p.Column.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Column, err)
	}
	return nil
}

func (p *AddColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("addColumnFamily_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AddColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.TableName, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *AddColumnFamilyArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:column: %s", p, err)
	}
	if err := p.Column.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Column, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:column: %s", p, err)
	}
	return err
}

func (p *AddColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AddColumnFamilyArgs(%+v)", *p)
}

type AddColumnFamilyResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewAddColumnFamilyResult() *AddColumnFamilyResult {
	return &AddColumnFamilyResult{}
}

var AddColumnFamilyResult_Io_DEFAULT *TIOError

func (p *AddColumnFamilyResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return AddColumnFamilyResult_Io_DEFAULT
	}
	return p.Io
}
func (p *AddColumnFamilyResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *AddColumnFamilyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AddColumnFamilyResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *AddColumnFamilyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("addColumnFamily_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AddColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *AddColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AddColumnFamilyResult(%+v)", *p)
}

type DeleteColumnFamilyArgs struct {
	TableName *TTableName `thrift:"tableName,1,required" json:"tableName"`
	Column    []byte      `thrift:"column,2,required" json:"column"`
}

func NewDeleteColumnFamilyArgs() *DeleteColumnFamilyArgs {
	return &DeleteColumnFamilyArgs{}
}

var DeleteColumnFamilyArgs_TableName_DEFAULT *TTableName

func (p *DeleteColumnFamilyArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return DeleteColumnFamilyArgs_TableName_DEFAULT
	}
	return p.TableName
}

func (p *DeleteColumnFamilyArgs) GetColumn() []byte {
	return p.Column
}
func (p *DeleteColumnFamilyArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *DeleteColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteColumnFamilyArgs) ReadField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.TableName, err)
	}
	return nil
}

func (p *DeleteColumnFamilyArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Column = v
	}
	return nil
}

func (p *DeleteColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteColumnFamily_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.TableName, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *DeleteColumnFamilyArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:column: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Column); err != nil {
		return fmt.Errorf("%T.column (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:column: %s", p, err)
	}
	return err
}

func (p *DeleteColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteColumnFamilyArgs(%+v)", *p)
}

type DeleteColumnFamilyResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewDeleteColumnFamilyResult() *DeleteColumnFamilyResult {
	return &DeleteColumnFamilyResult{}
}

var DeleteColumnFamilyResult_Io_DEFAULT *TIOError

func (p *DeleteColumnFamilyResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return DeleteColumnFamilyResult_Io_DEFAULT
	}
	return p.Io
}
func (p *DeleteColumnFamilyResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *DeleteColumnFamilyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteColumnFamilyResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteColumnFamilyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteColumnFamily_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteColumnFamilyResult(%+v)", *p)
}

type ModifyColumnFamilyArgs struct {
	TableName *TTableName              `thrift:"tableName,1,required" json:"tableName"`
	Column    *TColumnFamilyDescriptor `thrift:"column,2,required" json:"column"`
}

func NewModifyColumnFamilyArgs() *ModifyColumnFamilyArgs {
	return &ModifyColumnFamilyArgs{}
}

var ModifyColumnFamilyArgs_TableName_DEFAULT *TTableName

func (p *ModifyColumnFamilyArgs) GetTableName() *TTableName {
	if !p.IsSetTableName() {
		return ModifyColumnFamilyArgs_TableName_DEFAULT
	}
	return p.TableName
}

var ModifyColumnFamilyArgs_Column_DEFAULT *TColumnFamilyDescriptor

func (p *ModifyColumnFamilyArgs) GetColumn() *TColumnFamilyDescriptor {
	if !p.IsSetColumn() {
		return ModifyColumnFamilyArgs_Column_DEFAULT
	}
	return p.Column
}
func (p *ModifyColumnFamilyArgs) IsSetTableName() bool {
	return p.TableName != nil
}

func (p *ModifyColumnFamilyArgs) IsSetColumn() bool {
	return p.Column != nil
}

func (p *ModifyColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ModifyColumnFamilyArgs) ReadField1(iprot thrift.TProtocol) error {
	p.TableName = &TTableName{}
	if err := p.TableName.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.TableName, err)
	}
	return nil
}

func (p *ModifyColumnFamilyArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Column = &TColumnFamilyDescriptor{}
	if err := p.Column.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Column, err)
	}
	return nil
}

func (p *ModifyColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("modifyColumnFamily_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ModifyColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := p.TableName.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.TableName, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *ModifyColumnFamilyArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:column: %s", p, err)
	}
	if err := p.Column.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Column, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:column: %s", p, err)
	}
	return err
}

func (p *ModifyColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ModifyColumnFamilyArgs(%+v)", *p)
}

type ModifyColumnFamilyResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewModifyColumnFamilyResult() *ModifyColumnFamilyResult {
	return &ModifyColumnFamilyResult{}
}

var ModifyColumnFamilyResult_Io_DEFAULT *TIOError

func (p *ModifyColumnFamilyResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return ModifyColumnFamilyResult_Io_DEFAULT
	}
	return p.Io
}
func (p *ModifyColumnFamilyResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *ModifyColumnFamilyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ModifyColumnFamilyResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ModifyColumnFamilyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("modifyColumnFamily_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ModifyColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ModifyColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ModifyColumnFamilyResult(%+v)", *p)
}

type ModifyTableArgs struct {
	Desc *TTableDescriptor `thrift:"desc,1,required" json:"desc"`
}

func NewModifyTableArgs() *ModifyTableArgs {
	return &ModifyTableArgs{}
}

var ModifyTableArgs_Desc_DEFAULT *TTableDescriptor

func (p *ModifyTableArgs) GetDesc() *TTableDescriptor {
	if !p.IsSetDesc() {
		return ModifyTableArgs_Desc_DEFAULT
	}
	return p.Desc
}
func (p *ModifyTableArgs) IsSetDesc() bool {
	return p.Desc != nil
}

func (p *ModifyTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ModifyTableArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Desc = &TTableDescriptor{}
	if err := p.Desc.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Desc, err)
	}
	return nil
}

func (p *ModifyTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("modifyTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ModifyTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("desc", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:desc: %s", p, err)
	}
	if err := p.Desc.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Desc, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:desc: %s", p, err)
	}
	return err
}

func (p *ModifyTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ModifyTableArgs(%+v)", *p)
}

type ModifyTableResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewModifyTableResult() *ModifyTableResult {
	return &ModifyTableResult{}
}

var ModifyTableResult_Io_DEFAULT *TIOError

func (p *ModifyTableResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return ModifyTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *ModifyTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *ModifyTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ModifyTableResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ModifyTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("modifyTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ModifyTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ModifyTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ModifyTableResult(%+v)", *p)
}

type CreateNamespaceArgs struct {
	NamespaceDesc *TNamespaceDescriptor `thrift:"namespaceDesc,1,required" json:"namespaceDesc"`
}

func NewCreateNamespaceArgs() *CreateNamespaceArgs {
	return &CreateNamespaceArgs{}
}

var CreateNamespaceArgs_NamespaceDesc_DEFAULT *TNamespaceDescriptor

func (p *CreateNamespaceArgs) GetNamespaceDesc() *TNamespaceDescriptor {
	if !p.IsSetNamespaceDesc() {
		return CreateNamespaceArgs_NamespaceDesc_DEFAULT
	}
	return p.NamespaceDesc
}
func (p *CreateNamespaceArgs) IsSetNamespaceDesc() bool {
	return p.NamespaceDesc != nil
}

func (p *CreateNamespaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateNamespaceArgs) ReadField1(iprot thrift.TProtocol) error {
	p.NamespaceDesc = &TNamespaceDescriptor{}
	if err := p.NamespaceDesc.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NamespaceDesc, err)
	}
	return nil
}

func (p *CreateNamespaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createNamespace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateNamespaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("namespaceDesc", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:namespaceDesc: %s", p, err)
	}
	if err := p.NamespaceDesc.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.NamespaceDesc, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:namespaceDesc: %s", p, err)
	}
	return err
}

func (p *CreateNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateNamespaceArgs(%+v)", *p)
}

type CreateNamespaceResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewCreateNamespaceResult() *CreateNamespaceResult {
	return &CreateNamespaceResult{}
}

var CreateNamespaceResult_Io_DEFAULT *TIOError

func (p *CreateNamespaceResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return CreateNamespaceResult_Io_DEFAULT
	}
	return p.Io
}
func (p *CreateNamespaceResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *CreateNamespaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateNamespaceResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *CreateNamespaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createNamespace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateNamespaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CreateNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateNamespaceResult(%+v)", *p)
}

type ModifyNamespaceArgs struct {
	NamespaceDesc *TNamespaceDescriptor `thrift:"namespaceDesc,1,required" json:"namespaceDesc"`
}

func NewModifyNamespaceArgs() *ModifyNamespaceArgs {
	return &ModifyNamespaceArgs{}
}

var ModifyNamespaceArgs_NamespaceDesc_DEFAULT *TNamespaceDescriptor

func (p *ModifyNamespaceArgs) GetNamespaceDesc() *TNamespaceDescriptor {
	if !p.IsSetNamespaceDesc() {
		return ModifyNamespaceArgs_NamespaceDesc_DEFAULT
	}
	return p.NamespaceDesc
}
func (p *ModifyNamespaceArgs) IsSetNamespaceDesc() bool {
	return p.NamespaceDesc != nil
}

func (p *ModifyNamespaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ModifyNamespaceArgs) ReadField1(iprot thrift.TProtocol) error {
	p.NamespaceDesc = &TNamespaceDescriptor{}
	if err := p.NamespaceDesc.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NamespaceDesc, err)
	}
	return nil
}

func (p *ModifyNamespaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("modifyNamespace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ModifyNamespaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("namespaceDesc", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:namespaceDesc: %s", p, err)
	}
	if err := p.NamespaceDesc.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.NamespaceDesc, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:namespaceDesc: %s", p, err)
	}
	return err
}

func (p *ModifyNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ModifyNamespaceArgs(%+v)", *p)
}

type ModifyNamespaceResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewModifyNamespaceResult() *ModifyNamespaceResult {
	return &ModifyNamespaceResult{}
}

var ModifyNamespaceResult_Io_DEFAULT *TIOError

func (p *ModifyNamespaceResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return ModifyNamespaceResult_Io_DEFAULT
	}
	return p.Io
}
func (p *ModifyNamespaceResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *ModifyNamespaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ModifyNamespaceResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ModifyNamespaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("modifyNamespace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ModifyNamespaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ModifyNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ModifyNamespaceResult(%+v)", *p)
}

type DeleteNamespaceArgs struct {
	Name string `thrift:"name,1,required" json:"name"`
}

func NewDeleteNamespaceArgs() *DeleteNamespaceArgs {
	return &DeleteNamespaceArgs{}
}

func (p *DeleteNamespaceArgs) GetName() string {
	return p.Name
}
func (p *DeleteNamespaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteNamespaceArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *DeleteNamespaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteNamespace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteNamespaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *DeleteNamespaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteNamespaceArgs(%+v)", *p)
}

type DeleteNamespaceResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewDeleteNamespaceResult() *DeleteNamespaceResult {
	return &DeleteNamespaceResult{}
}

var DeleteNamespaceResult_Io_DEFAULT *TIOError

func (p *DeleteNamespaceResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return DeleteNamespaceResult_Io_DEFAULT
	}
	return p.Io
}
func (p *DeleteNamespaceResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *DeleteNamespaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteNamespaceResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteNamespaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteNamespace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteNamespaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteNamespaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteNamespaceResult(%+v)", *p)
}

type GetNamespaceDescriptorArgs struct {
	Name string `thrift:"name,1,required" json:"name"`
}

func NewGetNamespaceDescriptorArgs() *GetNamespaceDescriptorArgs {
	return &GetNamespaceDescriptorArgs{}
}

func (p *GetNamespaceDescriptorArgs) GetName() string {
	return p.Name
}
func (p *GetNamespaceDescriptorArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNamespaceDescriptorArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *GetNamespaceDescriptorArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getNamespaceDescriptor_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNamespaceDescriptorArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *GetNamespaceDescriptorArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNamespaceDescriptorArgs(%+v)", *p)
}

type GetNamespaceDescriptorResult struct {
	Success *TNamespaceDescriptor `thrift:"success,0" json:"success"`
	Io      *TIOError             `thrift:"io,1" json:"io"`
}

func NewGetNamespaceDescriptorResult() *GetNamespaceDescriptorResult {
	return &GetNamespaceDescriptorResult{}
}

var GetNamespaceDescriptorResult_Success_DEFAULT *TNamespaceDescriptor

func (p *GetNamespaceDescriptorResult) GetSuccess() *TNamespaceDescriptor {
	if !p.IsSetSuccess() {
		return GetNamespaceDescriptorResult_Success_DEFAULT
	}
	return p.Success
}

var GetNamespaceDescriptorResult_Io_DEFAULT *TIOError

func (p *GetNamespaceDescriptorResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return GetNamespaceDescriptorResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetNamespaceDescriptorResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetNamespaceDescriptorResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetNamespaceDescriptorResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetNamespaceDescriptorResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TNamespaceDescriptor{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetNamespaceDescriptorResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetNamespaceDescriptorResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getNamespaceDescriptor_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetNamespaceDescriptorResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetNamespaceDescriptorResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetNamespaceDescriptorResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetNamespaceDescriptorResult(%+v)", *p)
}

type ListNamespaceDescriptorsArgs struct {
}

func NewListNamespaceDescriptorsArgs() *ListNamespaceDescriptorsArgs {
	return &ListNamespaceDescriptorsArgs{}
}

func (p *ListNamespaceDescriptorsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListNamespaceDescriptorsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("listNamespaceDescriptors_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ListNamespaceDescriptorsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListNamespaceDescriptorsArgs(%+v)", *p)
}

type ListNamespaceDescriptorsResult struct {
	Success []*TNamespaceDescriptor `thrift:"success,0" json:"success"`
	Io      *TIOError               `thrift:"io,1" json:"io"`
}

func NewListNamespaceDescriptorsResult() *ListNamespaceDescriptorsResult {
	return &ListNamespaceDescriptorsResult{}
}

var ListNamespaceDescriptorsResult_Success_DEFAULT []*TNamespaceDescriptor

func (p *ListNamespaceDescriptorsResult) GetSuccess() []*TNamespaceDescriptor {
	return p.Success
}

var ListNamespaceDescriptorsResult_Io_DEFAULT *TIOError

func (p *ListNamespaceDescriptorsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return ListNamespaceDescriptorsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *ListNamespaceDescriptorsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListNamespaceDescriptorsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *ListNamespaceDescriptorsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListNamespaceDescriptorsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TNamespaceDescriptor, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem150 := &TNamespaceDescriptor{}
		if err := _elem150.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem150, err)
		}
		p.Success = append(p.Success, _elem150)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ListNamespaceDescriptorsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ListNamespaceDescriptorsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("listNamespaceDescriptors_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ListNamespaceDescriptorsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ListNamespaceDescriptorsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ListNamespaceDescriptorsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListNamespaceDescriptorsResult(%+v)", *p)
}

type ListNamespacesArgs struct {
}

func NewListNamespacesArgs() *ListNamespacesArgs {
	return &ListNamespacesArgs{}
}

func (p *ListNamespacesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListNamespacesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("listNamespaces_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ListNamespacesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListNamespacesArgs(%+v)", *p)
}

type ListNamespacesResult struct {
	Success []string  `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewListNamespacesResult() *ListNamespacesResult {
	return &ListNamespacesResult{}
}

var ListNamespacesResult_Success_DEFAULT []string

func (p *ListNamespacesResult) GetSuccess() []string {
	return p.Success
}

var ListNamespacesResult_Io_DEFAULT *TIOError

func (p *ListNamespacesResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return ListNamespacesResult_Io_DEFAULT
	}
	return p.Io
}
func (p *ListNamespacesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ListNamespacesResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *ListNamespacesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListNamespacesResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]string, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem151 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem151 = v
		}
		p.Success = append(p.Success, _elem151)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ListNamespacesResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ListNamespacesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("listNamespaces_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ListNamespacesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ListNamespacesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ListNamespacesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListNamespacesResult(%+v)", *p)
}

type GetThriftServerTypeArgs struct {
}

func NewGetThriftServerTypeArgs() *GetThriftServerTypeArgs {
	return &GetThriftServerTypeArgs{}
}

func (p *GetThriftServerTypeArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetThriftServerTypeArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getThriftServerType_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetThriftServerTypeArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetThriftServerTypeArgs(%+v)", *p)
}

type GetThriftServerTypeResult struct {
	Success *TThriftServerType `thrift:"success,0" json:"success"`
}

func NewGetThriftServerTypeResult() *GetThriftServerTypeResult {
	return &GetThriftServerTypeResult{}
}

var GetThriftServerTypeResult_Success_DEFAULT TThriftServerType

func (p *GetThriftServerTypeResult) GetSuccess() TThriftServerType {
	if !p.IsSetSuccess() {
		return GetThriftServerTypeResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *GetThriftServerTypeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetThriftServerTypeResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetThriftServerTypeResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := TThriftServerType(v)
		p.Success = &temp
	}
	return nil
}

func (p *GetThriftServerTypeResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getThriftServerType_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetThriftServerTypeResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetThriftServerTypeResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetThriftServerTypeResult(%+v)", *p)
}

type GetSlowLogResponsesArgs struct {
	ServerNames    map[*TServerName]bool `thrift:"serverNames,1" json:"serverNames"`
	LogQueryFilter *TLogQueryFilter      `thrift:"logQueryFilter,2" json:"logQueryFilter"`
}

func NewGetSlowLogResponsesArgs() *GetSlowLogResponsesArgs {
	return &GetSlowLogResponsesArgs{}
}

func (p *GetSlowLogResponsesArgs) GetServerNames() map[*TServerName]bool {
	return p.ServerNames
}

var GetSlowLogResponsesArgs_LogQueryFilter_DEFAULT *TLogQueryFilter

func (p *GetSlowLogResponsesArgs) GetLogQueryFilter() *TLogQueryFilter {
	if !p.IsSetLogQueryFilter() {
		return GetSlowLogResponsesArgs_LogQueryFilter_DEFAULT
	}
	return p.LogQueryFilter
}
func (p *GetSlowLogResponsesArgs) IsSetLogQueryFilter() bool {
	return p.LogQueryFilter != nil
}

func (p *GetSlowLogResponsesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSlowLogResponsesArgs) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadSetBegin()
	if err != nil {
		return fmt.Errorf("error reading set begin: %s", err)
	}
	tSet := make(map[*TServerName]bool, size)
	p.ServerNames = tSet
	for i := 0; i < size; i++ {
		_elem152 := &TServerName{}
		if err := _elem152.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem152, err)
		}
		p.ServerNames[_elem152] = true
	}
	if err := iprot.ReadSetEnd(); err != nil {
		return fmt.Errorf("error reading set end: %s", err)
	}
	return nil
}

func (p *GetSlowLogResponsesArgs) ReadField2(iprot thrift.TProtocol) error {
	p.LogQueryFilter = &TLogQueryFilter{
		Limit: 10,

		LogType: 1,

		FilterByOperator: 1,
	}
	if err := p.LogQueryFilter.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.LogQueryFilter, err)
	}
	return nil
}

func (p *GetSlowLogResponsesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getSlowLogResponses_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSlowLogResponsesArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("serverNames", thrift.SET, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:serverNames: %s", p, err)
	}
	if err := oprot.WriteSetBegin(thrift.STRUCT, len(p.ServerNames)); err != nil {
		return fmt.Errorf("error writing set begin: %s", err)
	}
	for v, _ := range p.ServerNames {
		if err := v.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", v, err)
		}
	}
	if err := oprot.WriteSetEnd(); err != nil {
		return fmt.Errorf("error writing set end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:serverNames: %s", p, err)
	}
	return err
}

func (p *GetSlowLogResponsesArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("logQueryFilter", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:logQueryFilter: %s", p, err)
	}
	if err := p.LogQueryFilter.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.LogQueryFilter, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:logQueryFilter: %s", p, err)
	}
	return err
}

func (p *GetSlowLogResponsesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSlowLogResponsesArgs(%+v)", *p)
}

type GetSlowLogResponsesResult struct {
	Success []*TOnlineLogRecord `thrift:"success,0" json:"success"`
	Io      *TIOError           `thrift:"io,1" json:"io"`
}

func NewGetSlowLogResponsesResult() *GetSlowLogResponsesResult {
	return &GetSlowLogResponsesResult{}
}

var GetSlowLogResponsesResult_Success_DEFAULT []*TOnlineLogRecord

func (p *GetSlowLogResponsesResult) GetSuccess() []*TOnlineLogRecord {
	return p.Success
}

var GetSlowLogResponsesResult_Io_DEFAULT *TIOError

func (p *GetSlowLogResponsesResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return GetSlowLogResponsesResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetSlowLogResponsesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetSlowLogResponsesResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetSlowLogResponsesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSlowLogResponsesResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TOnlineLogRecord, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem153 := &TOnlineLogRecord{}
		if err := _elem153.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem153, err)
		}
		p.Success = append(p.Success, _elem153)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetSlowLogResponsesResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetSlowLogResponsesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getSlowLogResponses_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSlowLogResponsesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetSlowLogResponsesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetSlowLogResponsesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSlowLogResponsesResult(%+v)", *p)
}

type ClearSlowLogResponsesArgs struct {
	ServerNames map[*TServerName]bool `thrift:"serverNames,1" json:"serverNames"`
}

func NewClearSlowLogResponsesArgs() *ClearSlowLogResponsesArgs {
	return &ClearSlowLogResponsesArgs{}
}

func (p *ClearSlowLogResponsesArgs) GetServerNames() map[*TServerName]bool {
	return p.ServerNames
}
func (p *ClearSlowLogResponsesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ClearSlowLogResponsesArgs) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadSetBegin()
	if err != nil {
		return fmt.Errorf("error reading set begin: %s", err)
	}
	tSet := make(map[*TServerName]bool, size)
	p.ServerNames = tSet
	for i := 0; i < size; i++ {
		_elem154 := &TServerName{}
		if err := _elem154.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem154, err)
		}
		p.ServerNames[_elem154] = true
	}
	if err := iprot.ReadSetEnd(); err != nil {
		return fmt.Errorf("error reading set end: %s", err)
	}
	return nil
}

func (p *ClearSlowLogResponsesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("clearSlowLogResponses_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ClearSlowLogResponsesArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("serverNames", thrift.SET, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:serverNames: %s", p, err)
	}
	if err := oprot.WriteSetBegin(thrift.STRUCT, len(p.ServerNames)); err != nil {
		return fmt.Errorf("error writing set begin: %s", err)
	}
	for v, _ := range p.ServerNames {
		if err := v.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", v, err)
		}
	}
	if err := oprot.WriteSetEnd(); err != nil {
		return fmt.Errorf("error writing set end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:serverNames: %s", p, err)
	}
	return err
}

func (p *ClearSlowLogResponsesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClearSlowLogResponsesArgs(%+v)", *p)
}

type ClearSlowLogResponsesResult struct {
	Success []bool    `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewClearSlowLogResponsesResult() *ClearSlowLogResponsesResult {
	return &ClearSlowLogResponsesResult{}
}

var ClearSlowLogResponsesResult_Success_DEFAULT []bool

func (p *ClearSlowLogResponsesResult) GetSuccess() []bool {
	return p.Success
}

var ClearSlowLogResponsesResult_Io_DEFAULT *TIOError

func (p *ClearSlowLogResponsesResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return ClearSlowLogResponsesResult_Io_DEFAULT
	}
	return p.Io
}
func (p *ClearSlowLogResponsesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ClearSlowLogResponsesResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *ClearSlowLogResponsesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ClearSlowLogResponsesResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]bool, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem155 bool
		if v, err := iprot.ReadBool(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem155 = v
		}
		p.Success = append(p.Success, _elem155)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ClearSlowLogResponsesResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ClearSlowLogResponsesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("clearSlowLogResponses_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ClearSlowLogResponsesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.BOOL, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := oprot.WriteBool(bool(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ClearSlowLogResponsesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ClearSlowLogResponsesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClearSlowLogResponsesResult(%+v)", *p)
}
